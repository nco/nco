#!/usr/bin/env bash

# ncremap, the NCO regridder and grid-file, map-file, and weight-generator

# Purpose: Generate weights (i.e., map-files) for and regrid (subsets of) netCDF files between different Swath, Curvilinear, Rectangular, and Unstructured data (SCRUD) horizontal grids, generate any required/requested global or regional rectangular grid, output SCRIP, UGRID, and/or skeleton data formats, and interpolate between any specified pure pressure or hybrid sigma/pressure grids

# Copyright (C) 2015--present Charlie Zender
# This file is part of NCO, the netCDF Operators. NCO is free software.
# You may redistribute and/or modify NCO under the terms of the 
# 3-Clause BSD License.

# You are permitted to link NCO with the HDF, netCDF, OPeNDAP, and UDUnits
# libraries and to distribute the resulting executables under the terms
# of the BSD, but in addition obeying the extra stipulations of the 
# HDF, netCDF, OPeNDAP, and UDUnits licenses.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# See the 3-Clause BSD License for more details.

# The original author of this software, Charlie Zender, seeks to improve
# it with your suggestions, contributions, bug-reports, and patches.
# Please contact the NCO project at http://nco.sf.net or write to
# Charlie Zender
# Department of Earth System Science
# University of California, Irvine
# Irvine, CA 92697-3100

# Prerequisites: Bash, NCO (also ESMF_RegridWeightGen and/or TempestRemap for full functionality)
# Script could use other shells, e.g., dash (Debian default) after rewriting function definitions and loops
# Debug with 'bash -x ncremap --dbg=dbg_lvl' where 0 <= dbg_lvl <= 5

# Source: https://github.com/nco/nco/tree/master/data/ncremap
# Documentation: http://nco.sf.net/nco.html#ncremap
# Additional Documentation:
# HowTo: https://acme-climate.atlassian.net/wiki/display/SIM/Generate%2C+Regrid%2C+and+Split+Climatologies+%28climo+files%29+with+ncclimo+and+ncremap
# E3SM Climatology Requirements: https://acme-climate.atlassian.net/wiki/display/ATM/Climo+Files+-+v0.3+AMIP+runs (includes useful discussion of normalization in comments section)
# Benchmarks: https://acme-climate.atlassian.net/wiki/spaces/ATM/pages/25231711/Validation+and+Benchmarking+of+Regridders

# Regridder works in one of four modes:
# 1. Free-will: Infer source and destination grids to generate map-file, then regrid
# 2. Old Grid: Use known-good destination grid to generate map-file then regrid
# 3. New Grid: Generate source-grid from ncks parameter string
# 4. Pre-Destination: Apply supplied map-file to all input files
# By default, ncremap deletes any intermediate grids and map-file that it generates
# Use Free-Will, Old-Grid, or New-Grid mode to process Swath-Like-Data (SLD) where each input may be a granule on a new grid, yet all inputs are to be regridded to the same output grid
# Use Pre-Destination mode to post-process models or analyses where all files are converted from the same source grid to the same destination grid so the map-file can be pre-generated and never change

# Insta-install:
# scp ~/nco/data/ncremap zender1@acme1.llnl.gov:bin
# scp ~/nco/data/ncremap andes.olcf.ornl.gov:bin_andes
# scp ~/nco/data/ncremap ac.zender@blues.lcrc.anl.gov:bin_blues
# scp ~/nco/data/ncremap ac.zender@chrysalis.lcrc.anl.gov:bin_chrysalis
# scp ~/nco/data/ncremap compy.pnl.gov:bin
# scp ~/nco/data/ncremap derecho.hpc.ucar.edu:bin
# scp ~/nco/data/ncremap dust.ess.uci.edu:bin
# scp ~/nco/data/ncremap e3sm.ess.uci.edu:bin
# scp ~/nco/data/ncremap frontier.olcf.ornl.gov:bin_frontier
# scp ~/nco/data/ncclimo imua.ess.uci.edu:bin
# scp ~/nco/data/ncclimo perlmutter-p1.nersc.gov:bin_perlmutter
# scp ~/nco/data/ncremap spectral.ess.uci.edu:bin
# scp dust.ess.uci.edu:bin/ncremap ~/bin
# scp dust.ess.uci.edu:bin/ncremap ${MY_BIN_DIR}
# scp zender@dust.ess.uci.edu:bin/ncremap ${MY_BIN_DIR}

# Set script name, directory, PID, run directory
drc_pwd=${PWD}
# Security: Explicitly unset IFS before wordsplitting, so Bash uses default IFS=<space><tab><newline>
unset IFS
# Set these before 'module' command which can overwrite ${BASH_SOURCE[0]}
# NB: dash supports $0 syntax, not ${BASH_SOURCE[0]} syntax
# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
spt_src="${BASH_SOURCE[0]}"
[[ -z "${spt_src}" ]] && spt_src="${0}" # Use ${0} when BASH_SOURCE is unavailable (e.g., dash)
while [ -h "${spt_src}" ]; do # Recursively resolve ${spt_src} until file is no longer a symlink
  drc_spt="$( cd -P "$( dirname "${spt_src}" )" && pwd )"
  spt_src="$(readlink "${spt_src}")"
  [[ ${spt_src} != /* ]] && spt_src="${drc_spt}/${spt_src}" # If ${spt_src} was relative symlink, resolve it relative to path where symlink file was located
done
cmd_ln="${spt_src} ${@}"
drc_spt="$( cd -P "$( dirname "${spt_src}" )" && pwd )"
spt_nm=$(basename ${spt_src}) # [sng] Script name (unlike $0, ${BASH_SOURCE[0]} works well with 'source <script>')
spt_pid=$$ # [nbr] Script PID (process ID)

# https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/hdf5-1.10.1/src/hdf5-1.10.1-RELEASE.txt
# "The file locking calls used in HDF5 1.10.0 (including patch1) will fail when the underlying file system does not support file locking or where locks have been disabled. To disable all file locking operations, an environment variable named HDF5_USE_FILE_LOCKING can be set to the five-character string 'FALSE'."
# 20200110 Qi Tang reports Cori batch scripts to generate map-files fail unless he sets this
# 20200131 Necessary whenever using OpenMP and netCDF4-linked library on any non-locking filesystem?
if [ -z "${HDF5_USE_FILE_LOCKING}" ]; then
    export HDF5_USE_FILE_LOCKING='FALSE'
fi # HDF5_USE_FILE_LOCKING

# 20221108: Passing environment variable NCO_PATH_OVERRIDE (NPO) to ncremap in batch queues fails on Cori
# Approaches that fail include: 1. export NPO='Yes';ncremap ... 2. export NPO='Yes' ncremap ...
# Direct approach that works is to pass NPO flag to ncremap via command-line switch
# Require that path-override switch to be first command-line option (i.e., $1) found with shell syntax
# ncremap/ncclimo implement NPO (though not getopt) logic prior to invoking NCO
# This switch is a no-op in main getopt() block below (since it has already been parsed here)
hrd_pth='No' # [sng] Hard-code machine-dependent paths/modules if HOSTNAME in database
if [ -n "${1}" ]; then
    if [ "${1}" = '--hrd_pth' ] || [ "${1}" = '--npo' ] || [ "${1}" = '--nco_path_override' ] || [ "${1}" = '--NCO_PATH_OVERRIDE' ]; then
	hrd_pth='Yes'
	NCO_PATH_OVERRIDE='Yes'
    fi # !hrd_pth
fi # !$1

# Configure paths at High-Performance Computer Centers (HPCCs) based on ${HOSTNAME}
if [ -z "${HOSTNAME}" ]; then
    if [ -f /bin/hostname ] && [ -x /bin/hostname ]; then
	export HOSTNAME=`/bin/hostname`
    elif [ -f /usr/bin/hostname ] && [ -x /usr/bin/hostname ]; then
	export HOSTNAME=`/usr/bin/hostname`
    fi # !hostname
fi # HOSTNAME
# Default input and output directory is ${DATA}
if [ -z "${DATA}" ]; then
    case "${HOSTNAME}" in 
	acme1* ) DATA="/home/${USER}" ; ;; # LLNL acme1 
	andes* ) DATA="/gpfs/alpine/world-shared/cli115/${USER}" ; ;; # OLCF andes compute nodes named andesNNN, 256 GB/node
	blues* | blogin* | b[0123456789][0123456789][0123456789] ) DATA="/lcrc/project/ACME/${USER}" ; ;; # ANL/LCRC blues compute nodes named bNNN, 36|64 cores|GB/node 
	chrysalis* | chrlogin* | chr-[0123456789][0123456789][0123456789][0123456789] ) DATA="/lcrc/project/ACME/${USER}" ; ;; # ANL/LCRC chrysalis compute nodes named chr-NNNN, 64|256 cores|GB/node 
	*cheyenne* ) DATA="/glade/p/work/${USER}" ; ;; # NCAR cheyenne compute nodes named, e.g., r8i0n8, r5i3n16, r12i5n29 ... 18|(64/128) cores|GB/node (cheyenne login nodes 256 GB)
	compy* | n[0123456789][0123456789][0123456789][0123456789] ) DATA="/qfs/people/${USER}/data" ; ;; # PNNL compy compute nodes all named nNNNN, 40|192 cores|GB/node (compy login nodes also 192 GB)
	constance* | node* ) DATA='/scratch' ; ;; # PNNL
	frontier* ) DATA="/lustre/orion/cli115/world-shared/${USER}" ; ;; # OLCF frontier compute nodes named frontier01276 64|512 cores|GB/node
	login[0123456789][0123456789] ) # 20230831 Frontier and Perlmutter login nodes share this name :(
	    if [ "${LMOD_SYSTEM_NAME}" = 'frontier' ]; then
		DATA="/lustre/orion/cli115/world-shared/${USER}"
	    elif [ "${LMOD_SYSTEM_NAME}" = 'perlmutter' ]; then
		DATA="${SCRATCH}"
	    fi # !LMOD_SYSTEM_NAME
	    ;; # !login	
	perlmutter* | nid[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789] ) DATA="${SCRATCH}" ; ;; # NERSC perlmutter compute nodes named nidNNNNNN (CPU) with (64)|(512) cores|GB/node (cpu) (login nodes 512 GB)
	* ) DATA='/tmp' ; ;; # Other
    esac # !HOSTNAME
fi # DATA

# 20190423 Speed-up OpenMP processes on Cori KNL Intel builds (and possibly others)
# Environmental settings (e.g., OMP_PROC_BIND=spread or KMP_PROC_BIND=intel) may place all threads on same hardware core
# Problem only known to manifest when multiple instances of NCO are spawned on single node
OMP_PROC_BIND=false

# Ensure batch jobs access correct 'mpirun' (or, with SLURM, 'srun') command, netCDF library, and NCO executables and library
# 20170914 Entire block is identical between ncclimo and ncremap---keep it that way!
# 20190421 Change override default from opt-out to opt-in
# 20221108 Implement hrd_pth in block above prior to getopt()
# 20250903 Simplify code: Always define then re-use E3SMU_ROOT, then add E3SMU_ROOT/bin to path only for ncremap
# Leave NCO_PATH_OVERRIDE unset or set to 'No' to prevent NCO from executing next block that overrides PATH
# Set NCO_PATH_OVERRIDE to 'Yes' in environment to cause NCO to execute next block and to override PATH:
# export NCO_PATH_OVERRIDE='Yes'
if [ "${hrd_pth}" = 'Yes' ] && [ "${NCO_PATH_OVERRIDE}" = 'Yes' ]; then
    # If HOSTNAME is not in database, change hrd_pth_fnd to 'No' in case-statement default fall-through
    hrd_pth_fnd='Yes' # [sng] Machine-dependent paths/modules for HOSTNAME found in database
    case "${HOSTNAME}" in 
	acme1* )
	    E3SMU_ROOT='/p/user_pub/e3sm_unified/envs/base/envs/e3sm_unified_latest'
	    export PATH='/home/zender1/bin'\:${PATH}
            export LD_LIBRARY_PATH='/home/zender1/lib'\:${E3SMU_ROOT}/lib\:${LD_LIBRARY_PATH} ; ;;
	andes* )
	    # 20190827: Must guarantee finding mpirun
	    source ${MODULESHOME}/init/sh # 20150607: PMC Ensures find module commands will be found
	    E3SMU_ROOT='/ccs/proj/cli115/software/e3sm-unified/base/envs/e3sm_unified_latest'
            export PATH='/ccs/home/zender/bin_andes'\:${PATH}
	    export LD_LIBRARY_PATH='/ccs/home/zender/lib_andes'\:${E3SMU_ROOT}/lib\:${LD_LIBRARY_PATH} ; ;;
	blues* | blogin* | b[0123456789][0123456789][0123456789] )
	    E3SMU_ROOT='/lcrc/soft/climate/e3sm-unified/base/envs/e3sm_unified_latest'
	    export PATH='/home/zender/bin_blues'\:${PATH}
	    export LD_LIBRARY_PATH='/home/zender/lib_blues'\:${E3SMU_ROOT}/lib\:${LD_LIBRARY_PATH} ; ;;
	chrysalis* | chrlogin* | chr-[0123456789][0123456789][0123456789][0123456789] )
	    E3SMU_ROOT='/lcrc/soft/climate/e3sm-unified/base/envs/e3sm_unified_latest'
	    export PATH='/home/ac.zender/bin_chrysalis'\:${PATH}
	    export LD_LIBRARY_PATH='/home/ac.zender/lib_chrysalis'\:${E3SMU_ROOT}/lib\:${LD_LIBRARY_PATH} ; ;;
	compy* | n[0123456789][0123456789][0123456789][0123456789] )
	    module purge
	    module load gcc/10.2.0
	    # 20210519: This script takes significant time (5-10 seconds) to load
	    # 20230914: Deprecate special MOAB paths, rely on E3SMU
	    # source /compyfs/software/mbtempest.envs.sh
	    E3SMU_ROOT='/share/apps/E3SM/conda_envs/base/envs/e3sm_unified_latest'
	    export PATH='/qfs/people/zender/bin:/qfs/people/zender/anaconda/bin'\:${PATH}
	    export LD_LIBRARY_PATH='/qfs/people/zender/lib:/qfs/people/zender/anaconda/lib'\:${LD_LIBRARY_PATH} ; ;;
	derecho* )
	    # 20240107: Derecho support not yet tested in batch mode
	    if [ ${spt_nm} = 'ncremap' ]; then
		# On cheyenne, module load ncl installs ERWG in /glade/u/apps/ch/opt/ncl/6.4.0/intel/17.0.1/bin (i.e., ${NCARG_ROOT}/bin)
		module load ncl
	    fi # !ncremap
	    if [ -n "${NCARG_ROOT}" ]; then
		export PATH="${PATH}:/glade/u/apps/ch/opt/ncl/6.6.2/gnu/8.3.0/bin"
	    fi # !NCARG_ROOT
            export PATH='/glade/u/home/zender/bin'\:${PATH}
            export LD_LIBRARY_PATH='/glade/u/apps/derecho/23.06/spack/opt/spack/netcdf/4.9.2/gcc/12.2.0/ok4t/lib:/glade/u/apps/derecho/23.06/spack/opt/spack/udunits/2.2.28/gcc/12.2.0/vls2/lib:/glade/u/apps/ch/opt/gsl/2.7/gnu/12.1.0/lib:/glade/u/home/zender/lib'\:${LD_LIBRARY_PATH} ; ;;
	e3sm* )
	    export PATH='/home/zender/bin:/home/zender/anaconda/bin'\:${PATH}
	    export LD_LIBRARY_PATH='/home/zender/lib:/home/zender/anaconda/lib'\:${LD_LIBRARY_PATH} ; ;;
	frontier* )
	    if [ ${spt_nm} = 'ncremap' ]; then
		E3SMU_ROOT='/ccs/proj/cli115/software/e3sm-unified/base/envs/e3sm_unified_latest'
	    fi # !ncremap
            export PATH='/ccs/home/zender/bin_frontier:/ccs/home/zender/anaconda/bin'\:${PATH}
	    export LD_LIBRARY_PATH='/ccs/home/zender/lib_frontier:/ccs/home/zender/anaconda/lib'\:${LD_LIBRARY_PATH} ; ;;
	login[0123456789][0123456789] ) # 20230831 Frontier and Perlmutter login nodes share this name :(
	    if [ "${LMOD_SYSTEM_NAME}" = 'frontier' ]; then
		E3SMU_ROOT='/ccs/proj/cli115/software/e3sm-unified/base/envs/e3sm_unified_latest'
		export PATH='/ccs/home/zender/bin_frontier:/ccs/home/zender/anaconda/bin'\:${PATH}
		export LD_LIBRARY_PATH='/ccs/home/zender/lib_frontier:/ccs/home/zender/anaconda/lib'\:${LD_LIBRARY_PATH}
	    elif [ "${LMOD_SYSTEM_NAME}" = 'perlmutter' ]; then
		# 20221103 Add build environment modules
		module load PrgEnv-gnu
		module load cray-hdf5/1.12.2.9
		module load cray-netcdf/4.9.0.9
		MOAB_ROOT=/project/projectdirs/e3sm/software/moab
		TEMPESTREMAP_ROOT=/project/projectdirs/e3sm/software/tempestremap
		E3SMU_ROOT='/global/common/software/e3sm/anaconda_envs/base/envs/e3sm_unified_latest'
		if [ -n "${NCARG_ROOT}" ]; then
		    export PATH="${PATH}:${NCARG_ROOT}/bin"
		    export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${NCARG_ROOT}/lib"
		fi # !NCARG_ROOT
		export PATH='/global/cfs/cdirs/e3sm/zender/bin_perlmutter'\:${PATH}
		export LD_LIBRARY_PATH='/global/cfs/cdirs/e3sm/zender/lib_perlmutter'\:${LD_LIBRARY_PATH}
	    fi # !LMOD_SYSTEM_NAME
	    ;; # !login	
	perlmutter* | nid[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789] )
	    # 20221103 Add build environment modules
	    module load PrgEnv-gnu
	    module load cray-hdf5/1.12.2.9
	    module load cray-netcdf/4.9.0.9
	    MOAB_ROOT=/project/projectdirs/e3sm/software/moab
	    TEMPESTREMAP_ROOT=/project/projectdirs/e3sm/software/tempestremap
	    E3SMU_ROOT='/global/common/software/e3sm/anaconda_envs/base/envs/e3sm_unified_latest'
	    if [ -n "${NCARG_ROOT}" ]; then
		export PATH="${PATH}:${NCARG_ROOT}/bin"
		export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${NCARG_ROOT}/lib"
	    fi # !NCARG_ROOT
	    export PATH='/global/cfs/cdirs/e3sm/zender/bin_perlmutter'\:${PATH}
            export LD_LIBRARY_PATH='/global/cfs/cdirs/e3sm/zender/lib_perlmutter'\:${E3SMU_ROOT}/lib\:${LD_LIBRARY_PATH} ; ;;
	* ) # Default fall-through
	    hrd_pth_fnd='No' ; ;;
    esac # !HOSTNAME
    if [ -n "${MOAB_ROOT}" ] && [ ${spt_nm} = 'ncremap' ]; then
	export PATH="${PATH}:${MOAB_ROOT}/bin"
	export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${MOAB_ROOT}/lib"
    fi # !MOAB_ROOT
    if [ -n "${TEMPESTREMAP_ROOT}" ] && [ ${spt_nm} = 'ncremap' ]; then
	export PATH="${PATH}:${TEMPESTREMAP_ROOT}/bin"
	export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${TEMPESTREMAP_ROOT}/lib"
    fi # !TEMPESTREMAP_ROOT
    # 20210519: E3SM-U supplies many uncommon executables and libraries, e.g., libantlr, ESMF_RegridWeightGen
    # 20241220: Now that ncclimo also regularly uses ncap2 executable for global timeseries, must modify its path too
    # ncclimo only needs access to E3SM_U libraries (e.g., libgsl, libantlr), already implemented above
    # ncremap needs access to E3SM_U binaries (ESMF_RegridWeightGen, ...) _and_ libraries
    # Append E3SM-U binaries to _end_ of PATH so NCO binaries not redirected, e.g., from CSZ's development directory to E3SM-U
    if [ -n "${E3SMU_ROOT}" ] && [ ${spt_nm} = 'ncremap' ]; then
	export PATH="${PATH}:${E3SMU_ROOT}/bin"
    fi # !E3SMU_ROOT
fi # !hrd_pth && !NCO_PATH_OVERRIDE

# Test cases (${DATA]/[grids/maps] refers to ~zender/data/[grids/maps] on Charlie's test machines)
# Debugging:
# ncremap --dbg=1 --var=FSDS --map=${DATA}/maps/map_ne30np4_to_cmip6_180x360_nco.20190601.nc ${DATA}/bm/eamv1_ne30np4l72.nc ~/foo.nc 2>&1 | m
# ncks -O --dbg=1 --var=FSDS --map=${DATA}/maps/map_ne30np4_to_cmip6_180x360_nco.20190601.nc ${DATA}/bm/eamv1_ne30np4l72.nc ~/foo.nc 2>&1 | m
# ncks -O --dbg=1 --var=TREFHT --map=${DATA}/maps/map_ne30pg2_to_cmip6_180x360_aave.20200201.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo.nc 2>&1 | m
# ncks -O --dbg=1 --var=FSDS --map=${DATA}/maps/map_ne30pg2_to_r05_traave.20240701.nc --nlm=${DATA}/maps/map_ne30pg2_to_r05_trfv2.20240701.nc ${DATA}/bm/eamv3_ne30pg2l80.nc ~/foo.nc 2>&1 | m
# Map-only, threading:
# ncremap --dbg=1 --thr_nbr=6 --vrb=3 --devnull=No --nco='--dbg=5' --alg_typ=ncoaave --grd_src=${DATA}/grids/ne30np4_pentagons.20190501.nc --grd_dst=${DATA}/grids/cmip6_180x360_scrip.20181001.nc --map=${HOME}/map.nc
# ncks -O --dbg=5 --thr_nbr=6 --grd_src=${DATA}/grids/ne30np4_pentagons.20190501.nc --grd_dst=${DATA}/grids/cmip6_180x360_scrip.20181001.nc --map=${HOME}/map.nc ~/nco/data/in.nc ~/foo.nc
# ncremap --dbg=1 --vrb=3 --devnull=No --nco='--dbg=1' --alg_typ=ncoidw --xtr_nsp=8 --xtr_xpn=2.0 --grd_src=${DATA}/grids/ne30np4_pentagons.20190501.nc --grd_dst=${DATA}/grids/cmip6_180x360_scrip.20181001.nc --map=${HOME}/map.nc
# ncremap --dbg=1 --alg_typ=bilin   --grd_src=${DATA}/grids/oEC60to30.SCRIP.150729.nc --grd_dst=${DATA}/grids/t62_scrip.20181001.nc --map=${HOME}/map.nc
# ncremap --dbg=1 --alg_typ=traave --grd_src=${DATA}/grids/oEC60to30.SCRIP.150729.nc --grd_dst=${DATA}/grids/t62_scrip.20181001.nc --map=${HOME}/map.nc
# ncremap --dbg=1 --alg_typ=traave --grd_src=${DATA}/grids/oEC60to30.SCRIP.150729.nc --tpl=${DATA}/dstmch90/dstmch90_clm.nc --map=${HOME}/map.nc
# ncremap --dbg=1 --alg_typ=traave --grd_src=${DATA}/grids/128x256_SCRIP.20160301.nc --tpl=${DATA}/dstmch90/dstmch90_clm.nc --map=${HOME}/map.nc
# Regression:
# ncremap -P eam -7 -L 1 -m ${DATA}/maps/map_ne30np4_to_cmip6_180x360_aave.20181001.nc ${DATA}/bm/eamv1_ne30np4l72.nc ~/foo_eamv1.nc
# ncremap -P eam -7 -L 1 -m ${DATA}/maps/map_ne30pg2_to_cmip6_180x360_aave.20200201.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo_eamv2.nc
# ncremap -P elm -7 -L 1 -m ${DATA}/maps/map_ne30np4_to_cmip6_180x360_aave.20181001.nc ${DATA}/bm/elmv1_ne30np4l15.nc ~/foo_elmv1.nc
# ncremap -P elm -7 -L 1 -m ${DATA}/maps/map_ne30pg2_to_cmip6_180x360_aave.20200201.nc ${DATA}/bm/elmv2_ne30pg2l15.nc ~/foo_elmv2.nc
# ncremap -P elm -7 -L 1 -m ${DATA}/maps/map_r05_to_cmip6_180x360_traave.20240901.nc ${DATA}/bm/elmv3_r05l15.nc ~/foo_elmv3.nc
# ncremap -P mpasseaice -7 -L 1 -m ${DATA}/maps/map_oEC60to30v3_to_cmip6_180x360_aave.20181001.nc ${DATA}/bm/msiv1_oEC60to30v3.nc ~/foo_msiv1.nc
# ncremap -P mpasseaice -7 -L 1 -m ${DATA}/maps/map_EC30to60E2r2_to_cmip6_180x360_aave.20220301.nc ${DATA}/bm/msiv2_EC30to60E2r2l5.nc ~/foo_msiv2.nc
# ncremap -P mpasseaice -7 -L 1 -m ${DATA}/maps/map_IcoswISC30E3r5_to_cmip6_180x360_traave.20231201.nc ${DATA}/bm/msiv3_IcoswISC30E3r5l5.nc ~/foo_msiv3.nc
# ncremap -P mpasocean -7 -L 1 -m ${DATA}/maps/map_oEC60to30v3_to_cmip6_180x360_aave.20181001.nc ${DATA}/bm/mpov1_oEC60to30v3l60.nc ~/foo_mpov1.nc
# ncremap -P mpasocean -7 -L 1 -m ${DATA}/maps/map_EC30to60E2r2_to_cmip6_180x360_aave.20220301.nc ${DATA}/bm/mpov2_EC30to60E2r2l60.nc ~/foo_mpov2.nc
# ncremap -P mpasocean -7 -L 1 -m ${DATA}/maps/map_IcoswISC30E3r5_to_cmip6_180x360_traave.20231201.nc ${DATA}/bm/mpov3_IcoswISC30E3r5l64.nc ~/foo_mpov3.nc
# ncremap -P eamxx -7 -L 1 -m ${DATA}/maps/map_ne1024pg2_to_fv256x512_mono.20201201.nc ${DATA}/bm/screamv1_ne1024pg2l128.nc ~/foo_eamxx.nc
# ncremap --ps_nm=lnsp -v asn,t --vrt_out=${DATA}/grids/vrt_hyb_L72.nc ${DATA}/hdf/ecmwf_ifs_f640L137.nc ~/foo.nc
# Regrid:
# ls ${DATA}/ne30/raw/*1979*.nc | ncremap -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc -O ${DATA}/ne30/rgr
# ls ${DATA}/ne30/raw/*1979*.nc | ncremap -j 3 -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc -O ${DATA}/ne30/rgr # Batch-parallelism
# ncremap -a esmfaave -v FSNT -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -d ${DATA}/dstmch90/dstmch90_clm.nc -I ${DATA}/ne30/raw -O ${DATA}/ne30/rgr
# ls ${DATA}/essgcm14/essgcm14*cam*0007*.nc | ncremap -a esmfaave -M -d ${DATA}/dstmch90/dstmch90_clm.nc -O ${DATA}/ne30/rgr
# ncremap -a esmfaave -v FSNT -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -d ${DATA}/dstmch90/dstmch90_clm.nc -I ${DATA}/ne30/raw -O ${DATA}/ne30/rgr
# ncremap -P airs -v TSurfAir -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/AIRS.2014.10.01.202.L2.RetStd.v6.0.11.0.G14275134307.hdf ~/airs_out.nc
# ncremap -v CloudFrc_A -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/AIRS.2002.08.01.L3.RetStd_H031.v4.0.21.0.G06104133732.hdf ~/foo.nc
# ncremap -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/MOD04_L2.A2000055.0005.006.2014307165927.hdf ~/foo.nc
# ncremap -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/OMI-Aura_L2-OMIAuraSO2_2012m1222-o44888_v01-00-2014m0107t114720.h5 ~/foo.nc
# ncremap -v T -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/wrfout_v2_Lambert_notime.nc ~/foo.nc
# ncremap -v StepTwoO3 -d ${DATA}/hdf/cam_time.nc ${DATA}/hdf/OMI-Aura_L2-OMTO3_2015m0731t0034-o58727_v003-2015m0731t080836.he5.nc ~/foo.nc
# ncremap -v TSurfStd -G "--rgr grd_ttl='Default internally-generated grid' --rgr grid=${HOME}/rgr/ncremap_tmp_grd_dst.nc --rgr latlon=100,100 --rgr snwe=30.0,70.0,-130.0,-90.0" ${DATA}/sld/raw/AIRS.2014.10.01.202.L2.TSurfStd.Regrid010.1DLatLon.hole.nc ~/foo.nc
# ncremap -x TSurfStd_ct -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/sld/raw/AIRS.2014.10.01.202.L2.TSurfStd.Regrid010.1DLatLon.hole.nc ~/foo.nc
# CESM & E3SM:
# ncremap -s ${DATA}/grids/ne120np4_pentagons.100310.nc -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/ne120/raw/b1850c5_m2a.cam.h0.0060-01.nc ~/foo.nc
# Old MPAS filename conventions (until ~201609)::
# ncremap -P mpas -m ${DATA}/maps/map_oEC60to30_to_t62_bilin.20160301.nc ${DATA}/hdf/hist.ocn.0003-12-01_00.00.00.nc ~/foo.nc
# ncremap -P mpas -m ${DATA}/maps/map_mpas120_TO_T62_aave.121116.nc ${DATA}/hdf/hist.ice.0003-12-01_00.00.00.nc ~/foo.nc
# New MPAS filename conventions (as of ~201612):
# ncremap -P mpas -m ${DATA}/maps/map_oEC60to30_to_t62_bilin.20160301.nc ${DATA}/hdf/mpaso.hist.am.timeSeriesStatsMonthly.0001-01-01.nc ~/foo.nc
# ncremap -P mpas -m ${DATA}/maps/map_oEC60to30_to_t62_bilin.20160301.nc ${DATA}/hdf/mpascice.hist.am.timeSeriesStatsMonthly.0251-01-01.nc ~/foo.nc
# ncremap -P mpas --mss_val=-1.0e36 -s ${DATA}/grids/ais20km.150910.SCRIP.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ais20km.20180117.nc ~/foo.nc
# ncremap -P mpas --mss_val=-1.0e36 -s ${DATA}/grids/ais20km.150910.SCRIP.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/mpasLIoutput.nc ~/foo.nc
# ncremap -P mali -m ${DATA}/maps/map_mali_gis_to_greenland_r025_105x401_aave.20210301.nc ${DATA}/mpas/raw/mali.hist.0001-01-01_00000.nc ~/foo.nc
# E3SM benchmarks:
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_nco.20190601.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_cmip6_180x360_nco_idw.20200901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_mono.20190401.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_highorder.20190401.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_intbilin.20190401.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a esmfaave -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a conserve2nd -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS --rnr=0.99 --esmf_mth=idavg -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a ncoaave -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a trintbilin -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# Positional arguments:
# ncremap --var=FSNT,AODVIS --map=${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc --drc_out=${DATA}/ne30/rgr ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-??.nc
# Omit cell_measures:
# ncremap --no_cll_msr --var=FSNT,AODVIS -i ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc -o ~/foo.nc
# SGS (201909):
# ncremap --sgs_frc=${DATA}/grids/elm_landfrac_ne30np4.nc/landfrac -m ${DATA}/maps/map_ne30np4_to_cmip6_180x360_aave.20181001.nc ${DATA}/bm/elmv1_ne30np4l15.nc ~/foo.nc # External sgs_frc
# ncremap --vrb=3 --sgs_frc=landfrac --var=area,FSDS,landfrac,landmask,TBOT -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc ${DATA}/bm/elmv1_ne30np4l15.nc ~/elm_sgs.nc # 20190918 1D->2D works
# ncremap --vrb=3 --sgs_frc=landfrac --var=area,FSDS,landfrac,landmask,TBOT -m ${DATA}/maps/map_t42_to_fv129x256_aave.20150901.nc ${DATA}/essgcm14/essgcm14.clm2.h0.0000-01.nc ~/t42_rgr.nc # 20190918 2D->2D
# ncremap --vrb=3 -p serial --sgs_frc=landfrac -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc -O ${DATA}/ne30/rgr ${DATA}/ne30/raw/F_acmev03_enso_camse_clm45bgc_ne30_co2cycle.clm2.h0.2000-??.nc > ~/ncremap.out 2>&1 &
# ncremap --vrb=3 -a esmfaave --sgs_frc=aice --sgs_msk=tmask --sgs_nrm=100 --var=hi,uvel,aice,aisnap,albsno,blkmask,evap,evap_ai,fswabs,fswabs_ai,fswdn,fswthru,fswthru_ai,ice_present,snow,snow_ai,tarea,tmask,uarea -s ${DATA}/grids/gx1v7_151008.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170525 normalization required to get mask right
# ncremap --vrb=3 -a esmfaave -P cice --var=hi,uvel,aice,aisnap,albsno,blkmask,evap,evap_ai,fswabs,fswabs_ai,fswdn,fswthru,fswthru_ai,ice_present,snow,snow_ai,tarea,tmask,uarea -s ${DATA}/grids/gx1v7_151008.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170525 cice short-cut
# CICE/CESM on POP grid: full grid inferral (and thus conservative remapping) fails because masked vertices/cells missing, must use bilinear or supply grid-file for conservative
# ncremap -a bilinear -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170515: grid centers/bounds in non-masked regions suffice for bilinear interpolation
# ncremap -a esmfaave -s ${DATA}/grids/gx1v7_151008.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170521: conservative requires supplied tri-pole grid for centers/bounds in masked regions
# File-format
# ncremap -v FSNT,AODVIS -s ${DATA}/grids/ne30np4_pentagons.20190501.nc -d ${DATA}/dstmch90/dstmch90_clm.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo.nc
# TempestRemap boutique:
# GenerateCSMesh --alt --res 30 --file ${DATA}/grids/ne30.g (really should be ne30np4.g)
# ncremap --dbg=1 -a se2fv_flx --src_grd=${DATA}/grids/ne30.g --dst_grd=${DATA}/grids/129x256_SCRIP.20150901.nc -m ~/map_ne30np4_to_fv129x256_mono.20180301.nc
# ncremap --dbg=1 -m ~/map_ne30np4_to_fv129x256_mono.20180301.nc ${DATA}/bm/20180129.DECKv1b_piControl.ne30_oEC.edison.cam.h0.0001-01.nc ~/foo_fv129x256.nc
# ncremap --dbg=1 -a fv2se_stt --src_grd=${DATA}/grids/129x256_SCRIP.20150901.nc --dst_grd=${DATA}/grids/ne30.g -m ~/map_fv129x256_to_ne30np4_highorder.20180301.nc
# ncremap --dbg=1 -a fv2se_flx --src_grd=${DATA}/grids/129x256_SCRIP.20150901.nc --dst_grd=${DATA}/grids/ne30.g -m ~/map_fv129x256_to_ne30np4_monotr.20180301.nc
# ncremap --dbg=1 -m ~/map_fv129x256_to_ne30np4_highorder.20180301.nc ~/foo_fv129x256.nc ~/foo_ne30.nc
# Atmosphere->Ocean:
# ncremap --dbg=1 --a2o -a se2fv_flx --src_grd=${DATA}/grids/ne30.g --dst_grd=${DATA}/grids/129x256_SCRIP.20150901.nc -m ~/map_ne30np4_to_fv129x256_mono.20180301.nc
# Atmosphere->Atmosphere:
# ncremap --dbg=1 -a se2se --src_grd=${DATA}/grids/ne30.g --dst_grd=${DATA}/grids/ne30.g -m ~/map_ne30np4_to_ne30np4_se2se.20190301.nc
# RRG (201807):
# ncremap -D 1 -a esmfaave --rnm_sng='_128e_to_134e_9s_to_16s' --bb_wesn='128.0,134.0,-16.0,-9.0' --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc --grd_rgn=${HOME}/grd_rgn.nc ~/dat_rgn.nc ~/foo.nc > ~/ncremap.out 2>&1 &
# ncremap -D 0 --vrb=1 -a esmfaave --rnm_sng='_128e_to_134e_9s_to_16s' --bb_wesn='128.0,134.0,-16.0,-9.0' --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc --grd_dst=${HOME}/grd_rgn.nc --grd_src=${HOME}/grd_src.nc --map=${HOME}/map.nc ~/dat_rgn.nc ~/foo.nc
# ncremap -D 0 --vrb=1 -a esmfaave --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc --grd_dst=${HOME}/grd_rgn.nc --grd_src=${HOME}/grd_src.nc --map=${HOME}/map.nc ~/dat_rgn.nc ~/foo.nc
# ncremap -D 0 --vrb=1 -a esmfaave --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc -g ${HOME}/grd_rgn.nc ~/dat_rgn.nc ~/foo.nc
# MWF (202401):
# ncremap -D 1 -P mwf -s ${DATA}/grids/ocean.QU.240km.scrip.181106.nc -g ${DATA}/grids/ne11np4.g --nm_src=QU240 --nm_dst=ne11np4 --dt_sng=20240201 > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/ocean.IcoswISC30E3r5.mask.scrip.20231120.nc --grd_dst=${DATA}/grids/ne30pg2.g --nm_src=IcoswISC30E3r5 --nm_dst=ne30pg2 --dt_sng=20240201 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --alg_lst='traave,trbilin,trfv2' --grd_src=${DATA}/grids/ocean.IcoswISC30E3r5.mask.scrip.20231120.nc --grd_dst=${DATA}/grids/ne30pg2.g --nm_src=IcoswISC30E3r5 --nm_dst=ne30pg2 --dt_sng=20240201 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/ocean.IcoswISC30E3r5.mask.scrip.20231120.nc --grd_dst=${DATA}/grids/cmip6_180x360_scrip.nc --nm_src=IcoswISC30E3r5 --nm_dst=cmip6_180x360 --dt_sng=20240201 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/ocean.IcoswISC30E3r5.mask.scrip.20231120.nc --grd_dst=${DATA}/grids/cmip6_180x360.g --nm_src=IcoswISC30E3r5 --nm_dst=cmip6_180x360 --dt_sng=20240201 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/ne30pg2.g --grd_dst=${DATA}/grids/cmip6_180x360.g --nm_src=ne30pg2 --nm_dst=cmip6_180x360 --dt_sng=20240201 --drc_out=${DATA}/maps > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --wgt_cmd='mpirun -np 12 ESMF_RegridWeightGen' --grd_src=${DATA}/grids/ocean.IcoswISC30E3r5.mask.scrip.20231120.nc --grd_dst=${DATA}/grids/cmip6_180x360.nc --nm_src=IcoswISC30E3r5 --nm_dst=cmip6_180x360 --dt_sng=20240201 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# Add depth (201901):
# ncremap -P mpas --dpt_fl=${DATA}/grids/mpas_refBottomDepth_L60.nc -m ${DATA}/maps/map_oEC60to30v3_to_cmip6_180x360_aave.20181001.nc ${DATA}/hdf/mpaso.lrz.hist.am.timeSeriesStatsMonthly.0001-12-01.nc ~/foo.nc
# Vertical interpolation (201903):
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_out=${DATA}/grids/vrt_hyb_ne30np4l72_ps.nc ${DATA}/bm/eamv1_ne30np4l72.nc ~/foo.nc # PS in "fat" template file
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_out=${DATA}/grids/vrt_hyb_L72.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo.nc # skinny template file
# Missing-value extrapolation (mss_val|nrs_ngh)
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_xtr=mss_val --vrt_out=${DATA}/grids/vrt_hyb_L72.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo.nc
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_xtr=mss_val --vrt_out=${DATA}/grids/vrt_prs_ncep_L19.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo.nc
# Pressure->Pressure
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_xtr=mss_val --vrt_out=${DATA}/grids/vrt_prs_ncep_L19.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo_L19.nc
# ncremap --vrt_xtr=mss_val --vrt_out=${DATA}/grids/vrt_prs_L3.nc ~/foo_L19.nc ~/foo.nc
# Simultaneous horizontal/vertical regridding L72->L30
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --map=${DATA}/maps/map_ne30pg2_to_cmip6_180x360_aave.20200201.nc --vrt_out=${DATA}/grids/vrt_hyb_L30.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo.nc
# ncremap -P mpasocean -v timeMonthly_avg_activeTracers_temperature,timeMonthly_avg_zMid --map=${DATA}/maps/map_EC30to60E2r2_to_cmip6_180x360_nco.20220301.nc --vrt_out=${DATA}/grids/vrt_dpt_L10.nc ${DATA}/bm/mpov2_EC30to60E2r2l60.nc ~/foo.nc # borken 20230222 since vrt_ntp (correctly) does not propagate timeMonthly_avg_zMid, yet horizontal regridder expects it
# ncremap -P mpasocean --map=${DATA}/maps/map_EC30to60E2r2_to_r025_nco.20230101.nc --vrt_out=${DATA}/hdf/woa18_ANN_T_S_z_vol_20200514.nc ${DATA}/bm/mpov2_EC30to60E2r2l60.nc ~/foo.nc
# SCREAM external surface pressure and input vertical grid (202211):
# ncremap -v T_mid --ps_nm=${DATA}/bm/screamv1_ne1024pg2l128_QrPsPsl.nc/ps --vrt_in=${DATA}/grids/vrt_hyb_L128.nc --vrt_out=${DATA}/grids/vrt_prs_ncep_L17.nc ${DATA}/bm/screamv1_ne1024pg2l128_QvT.nc ~/foo.nc
# ncremap -6 -P eamxx --map=${DATA}/maps/map_ne1024pg2_to_fv256x512_mono.20201201.nc ${DATA}/bm/screamv1_ne1024pg2l128.nc ~/foo.nc # Panoply breaks on CDF5 input
# Interpolate time-varying hybrid input
# ncremap -v FSNT,AODVIS,T,Q,U,V,Z3 --map=${DATA}/maps/map_ne30pg2_to_cmip6_180x360_aave.20200201.nc --drc_out=${DATA}/ne30/rgr ${DATA}/ne30/raw/v2.LR.historical_0101.eam.h0.2013-0[123].nc
# ncrcat -O -v FSNT,AODVIS,T,Q,U,V,Z3 ${DATA}/ne30/rgr/v2.LR.historical_0101.eam.h0.2013-0[12].nc ${DATA}/ne30/rgr/v2.LR.historical_0101.eam.h0.201301_201302.nc
# ncremap --dbg=3 -v FSNT,AODVIS,T,Q,U,V,Z3 --vrt_out=${DATA}/grids/vrt_prs_ncep_L17.nc ${DATA}/ne30/rgr/v2.LR.historical_0101.eam.h0.201301_201302.nc ~/foo.nc
# MOAB
# ncremap --mpi_nbr=8 -v FSNT,AODVIS --dbg=1 --vrb=3 --devnull=No --alg_typ=traave --grd_src=${DATA}/grids/ne30pg2.nc --grd_dst=${DATA}/grids/cmip6_180x360_scrip.20181001.nc --map=${HOME}/map.nc ${DATA}/bm/eamv2_ne30pg2l72.nc ~/foo.nc
# CDO
# cdo verifygrid grid_CMN-5x5.nc
# ncremap --dbg=1 --vrb=3 --devnull=No --alg_typ=cdo_bil --in_fl=${DATA}/grids/t42_skl.nc --dst_fl=${DATA}/ne30/rgr/hfc_ANN_200001_200012_climo.nc --map=${DATA}/maps/map_t42_to_cmip6_180x360_cdo.20210701.nc
# add_fll
# ncremap --dbg=1 --thr_nbr=6 --vrb=3 --devnull=No --nco='--dbg=1' --add_fll --map=${DATA}/maps/map_racmo_566x438_icemask_to_greenland_r025_100x250_nco.20210701.nc ${HOME}/racmo.smb.nofill.nc ~/foo_nco.nofill.nc
# msk_apl
# ncremap --dbg=1 --thr_nbr=6 --vrb=3 --devnull=No --nco='--dbg=1' --msk_apl --map=${DATA}/maps/map_racmo_566x438_icemask_to_greenland_r025_100x250_nco.20210701.nc ${HOME}/racmo.smb.nofill.nc ~/foo_nco.nofill.nc

# dbg_lvl: 0 = Quiet, print basic status during evaluation
#          1 = Print configuration, full commands, and status to output during evaluation
#          2 = As in dbg_lvl=1, but DO NOT EXECUTE COMMANDS (i.e., pretend to run but do not regrid anything)
#          3 = As in dbg_lvl=1, and pass debug level through to NCO/ncks

# 20220131 ncclimo/ncremap commands within scripts that open E3SMU environment
# (e.g., zppy-generated scripts) must be told where to find NCO binaries.
# Only necessary on login nodes since Spack handles this fine on compute nodes
if [ "${E3SMU_MPI}" = 'NOMPI' ] && [ -n "${E3SMU_SCRIPT}" ] && [ -n "${CONDA_PREFIX}" ]; then
   export PATH="${CONDA_PREFIX}/bin"\:${PATH}
fi # !E3SMU_MPI
# Set NCO version and directory
nco_exe=`which ncks`
if [ -z "${nco_exe}" ]; then
    echo "ERROR: Unable to find NCO, nco_exe = ${nco_exe}"
    echo "${spt_nm}: HINT Carefully examine your environment setup (e.g., .bashrc) to avoid inadvertently overriding (with, e.g., conda-initialization) paths intended to be provided by an analysis-package environment (e.g., E3SM-Unified)"
    exit 1
fi # !nco_exe
# StackOverflow method finds NCO directory
while [ -h "${nco_exe}" ]; do
  drc_nco="$( cd -P "$( dirname "${nco_exe}" )" && pwd )"
  nco_exe="$(readlink "${nco_exe}")"
  [[ ${nco_exe} != /* ]] && nco_exe="${drc_nco}/${nco_exe}"
done
drc_nco="$( cd -P "$( dirname "${nco_exe}" )" && pwd )"
nco_vrs=$(ncks --version 2>&1 > /dev/null | grep NCO | awk '{print $5}')
nco_sng=$(ncks --version 2>&1 > /dev/null | grep NCO | awk -F '"' '{print $2}')
# 20190218: Die quickly when NCO is found yet cannot run, e.g., due to linker errors
if [ -z "${nco_vrs}" ]; then
    echo "${spt_nm}: ERROR ${nco_exe} dies with error message on next line:"
    $(ncks --version)
    if [ "${NCO_PATH_OVERRIDE}" != 'Yes' ]; then
	printf "HINT: Run-time errors due to link issues (e.g., libraries missing or not found) might be solved at supported national labs (ALCF, NCAR, NERSC, OLCF, PNNL) by employing NCO machine-dependent hardcoded paths/modules. To try this, re-run command after setting \"export NCO_PATH_OVERRIDE=Yes\".\n"
    fi # !NCO_PATH_OVERRIDE
    exit 1
fi # !nco_vrs
lbr_vrs=$(ncks --library 2>&1 > /dev/null | awk '{print $6}')

# Detect and warn about mixed modules (for Qi Tang 20170531)
if [ "${drc_spt}" != "${drc_nco}" ]; then
    echo "INFO: Mixture of NCO scripts and binaries from different locations. Script ${spt_nm} is from directory ${drc_spt} while NCO binaries are from directory ${drc_nco}. Normally the script and binaries are from the same executables directory. This INFO may be safely ignored for customized scripts and/or binaries that the user has intentionally split into different directories."
    echo "HINT: Conflicting script and binary directories may result from 1) Hardcoding an NCO script and/or binary pathnames, 2) Incomplete NCO installations in one or more directories in the \$PATH environment variable, 3) (Re-)Installing or (re-)building NCO without issuing a \"hash -r\" command afterward to update the executable pathnames that the shell remembers from before."
fi # drc_spt

# When running in a terminal window (not in an non-interactive batch queue)...
if [ -n "${TERM}" ]; then
    # Set fonts for legibility
    if [ -x /usr/bin/tput ] && tput setaf 1 &> /dev/null; then
	fnt_bld=`tput bold` # Bold
	fnt_nrm=`tput sgr0` # Normal
	fnt_rvr=`tput smso` # Reverse
	fnt_tlc=`tput sitm` # Italic
    else
	fnt_bld="\e[1m" # Bold
	fnt_nrm="\e[0m" # Normal
	fnt_rvr="\e[07m" # Reverse
	fnt_tlc="\e[3m" # Italic
    fi # !tput
fi # !TERM

# Pre-define enumerated types used in defaults
par_bck='background' # [sng] Parallelism: background
par_mpi='mpi' # [sng] Parallelism: MPI
par_srl='serial' # [sng] Parallelism: serial
vrb_0=0 # [enm] Verbosity level: Quiet
vrb_1=1 # [enm] Verbosity level: Standard, minimal file I/O
vrb_2=2 # [enm] Verbosity level: All file I/O
vrb_3=3 # [enm] Verbosity level: English
vrb_4=4 # [enm] Verbosity level: Pedantic
fmt_sng_nc3='CLASSIC (netCDF3 classic CDF1)'
fmt_sng_nc4='NETCDF4 (netCDF4 extended HDF5)'
fmt_sng_nc5='64BIT_DATA (netCDF3/pnetCDF CDF5)'
fmt_sng_nc6='64BIT_OFFSET (netCDF3 64bit CDF2)'
fmt_sng_nc7='NETCDF4_CLASSIC (netCDF4 classic HDF5)'

# Defaults for command-line options and some derived variables
# Modify these defaults to save typing later
a2o_flg='No' # [flg] Atmosphere-to-ocean (only used by Tempest mesh generator)
add_fll='No' # [flg] Add _FillValue to fields with empty destination cells
alg_lst='esmfaave,esmfbilin,ncoaave,ncoidw,traave,trbilin,trfv2,trintbilin' # [sng] Algorithm list for MWF mode
alg_typ='ncoaave' # [sng] Algorithm for remapping (esmfaave|esmfbilin|bilinear|conserve|conserve2nd|nearestdtos|neareststod|patch|traave|trbilin|trfv2|trintbilin|se2fv_flx|se2fv_stt|se2fv_alt|se2se|fv2se_flx|fv2se_stt|fv2se_alt|fv2fv_flx|fv2fv_stt|ncoaave|nco_con|ncoidw|ncoidw)
att_flg='No' # [flg] Add/alter attributes (e.g., _FillValue) before regridding
bch_pbs='No' # [sng] PBS batch (non-interactive) job
bch_slr='No' # [sng] SLURM batch (non-interactive) job
chk_map='Yes' # [flg] Check map-file quality
cln_flg='Yes' # [flg] Clean-up (remove) intermediate files before exiting
clm_flg='No' # [flg] Assume MPAS attributes have already been fiddled with (e.g., ncremap was invoked by ncclimo in climo mode)
cmp_sng='' # [sng] Compression string
cnv_exe_mbt='mbconvert' # [sng] MOAB-Tempest SCRIP/Exodus conversion to H5M executable
#cnv_exe_tps='ConvertSCRIPToExodus' # Command was deprecated in 2022
cnv_exe_tps='ConvertMeshToExodus' # [sng] TempestRemap SCRIP and Mesh-to-Exodus conversion executable
cnv_opt_e2m='-o PARALLEL=WRITE_PART -O PARALLEL=BCAST_DELETE -O PARTITION=TRIVIAL -O PARALLEL_RESOLVE_SHARED_ENTS' # [sng] Recommended options to mbconvert for (high-resolution) Exodus to MOAB grids https://acme-climate.atlassian.net/wiki/spaces/ED/pages/932380820/Offline+remapping+workflow+with+mbtempest
col_dmn='' # [sng] Name of unstructured (column) dimension (for coupler files)
d2f_flg='No' # [flg] Convert double-precision fields to single-precision
d2f_opt='-M dbl_flt' # [sng] Option string to convert double-precision fields to single-precision
dbg_lvl=0 # [nbr] Debugging level
dfl_lvl='' # [enm] Deflate level
dpt_exe_mpas='add_depth.py' # [sng] Depth coordinate addition command for MPAS
dpt_flg='No' # [flg] Add depth coordinate to MPAS files
dpt_fl='' # [sng] Depth file with refBottomDepth for MPAS ocean
dpt_nm='' # [sng] Name of variable containing 3D depth/height in input file
#drc_in="${drc_pwd}" # [sng] Input file directory
drc_in='' # [sng] Input file directory
drc_in_xmp='~/drc_in' # [sng] Input file directory for examples
drc_out="${drc_pwd}" # [sng] Output file directory
drc_out_xmp="~/rgr" # [sng] Output file directory for examples
dst_fl='' # [sng] Destination file
dst_xmp='dst.nc' # [sng] Destination file for examples
dt_sng=`date +%Y%m%d` # [sng] Date string for MWF map names
dvn_flg='Yes' # [flg] Send internal NCO regridder output to /dev/null
esmf_typ='' # [sng] ESMF extrapolation type (nearestidavg|neareststod|none)
fl_fmt='' # [enm] Output file format
fl_nbr=0 # [nbr] Number of files to remap
flg_grd_only='No' # [flg] Create grid then exit before regridding
flg_hrz='No' # [flg] Perform horizontal regridding
# 20200119 appending attribute containing remap_command causes ncatted to fail, temporarily remove it
#gaa_sng="--gaa remap_script=${spt_nm} --gaa remap_command=\"'${cmd_ln}'\" --gaa remap_hostname=${HOSTNAME} --gaa remap_version=${nco_vrs}" # [sng] Global attributes to add
gaa_sng="--gaa remap_script=${spt_nm} --gaa remap_hostname=${HOSTNAME} --gaa remap_version=${nco_vrs}" # [sng] Global attributes to add
gad_sng='' # [sng] Global attributes to delete
grd_dst='' # [sng] Destination grid-file
grd_dst_xmp='grd_dst.nc' # [sng] Destination grid-file for examples
grd_sng='' # [sng] Grid string
grd_src='' # [sng] Source grid-file
grd_src_xmp='grd_src.nc' # [sng] Source grid-file for examples
grd_vrt_xmp='grd_vrt.nc' # [sng] Vertical grid-file for examples
hdr_pad='10000' # [B] Pad at end of header section
hnt_dst='' # [sng] ERWG hint for destination grid
hnt_src='' # [sng] ERWG hint for source grid
in_fl='' # [sng] Input file
in_xmp='in.nc' # [sng] Input file for examples
inp_aut='No' # [sng] Input file list automatically generated (in ncclimo, or specified with -i in ncremap)
inp_glb='No' # [sng] Input file list from globbing directory 
inp_psn='No' # [sng] Input file list from positional arguments
inp_std='No' # [sng] Input file list from stdin
job_nbr=2 # [nbr] Job simultaneity for parallelism
map_fl='' # [sng] Map-file
map_nfo_sng='' # [sng] Informational string about map-file
map_rsl_fl='' # [sng] File containing results of weight-generation command (i.e., map_fl or map_trn_fl for monotr)
map_trn_fl='' # [sng] Map-file transpose (for Tempest)
map_mk='No' # [flg] Generate map-file (i.e., map does not yet exist)
map_usr_flg='No' # [flg] User supplied argument to --map option
map_xmp='map.nc' # [sng] Map-file for examples
mbt_typ_grd=0 # [flg] mbtempest mesh type (CS=0, RLL=1, ICO=2, OVERLAP_FILES=3, OVERLAP_MEMORY=4, OVERLAP_MOAB=5])
mbt_typ_map=5 # [flg] mbtempest mesh type (CS=0, RLL=1, ICO=2, OVERLAP_FILES=3, OVERLAP_MEMORY=4, OVERLAP_MOAB=5])
mem_mb=0 # [MB] Megabytes of RAM per srun job in Cori SLURM in MPI mode (0 indicates unlimited RAM)
mlt_map_flg='Yes' # [sng] Multi-map flag
mpaso_var_zmid='timeMonthly_avg_zMid' # [sng] Name of MPAS-O 3D depth variable
mpi_flg='No' # [sng] Parallelize over nodes
mpi_nbr=1 # [sng] Number of tasks-per-node that MPI-enabled weight generators will request (should be factor of prt_nbr)
mpt_mss='No' # [flg] Set empty (sgs_frc==0.0) SGS cells to missing value
msh_exe_tps='GenerateOverlapMesh' # [sng] TempestRemap mesh-generation executable
msh_fl='' # [sng] Mesh-file (for Tempest)
msk_apl='No' # [flg] Apply msk_out to variables after regridding
msk_dst='' # [sng] Mask-template variable in destination file
msk_out='No' # [flg] Put mask variable in regridded file
msk_src='' # [sng] Mask-template variable in source file
mss_val='-9.99999979021476795361e+33' # [frc] Missing value for MPAS (ocean+seaice)
#mss_val='-1.0e36' # [frc] Missing value (MALI)
nco_opt='--no_tmp_fl' # [sng] NCO options (e.g., '-6 -t 1')
nd_nbr=1 # [nbr] Number of nodes
nsx_alg='' # [enm] Intersection algorithm (mbtempest only)
out_fl='' # [sng] Output file
out_xmp='out.nc' # [sng] Output file for examples
par_typ="${par_srl}" # [sng] Parallelism type
pdq_flg='Yes' # [sng] Permute dimensions before regridding
pdq_opt='' # [sng] ncpdq dimension permutation option
prc_sgs='No' # [sng] SGS requested
prc_typ='' # [sng] Procedure type
prt_alg='zoltan' # [sng] MOAB-Tempest H5M partition algorithm
prt_exe_mbt='mbpart' # [sng] MOAB-Tempest H5M partition executable
prt_nbr=8 # [nbr] Partition number for mbpart (should be multiple of mpi_nbr)
prs_stt='' # [sng] Preserved statistic ('integral' or 'mean')
ps_nm='' # [sng] Name of variable containing surface pressure in input file
ps_nm_dfl='PS' # [sng] Name of variable containing surface pressure in input file
ps_rtn='No' # [flg] Retain surface pressure variable in vertical interpolation output
qea_flg='No' # [sng] Quasi-equal area mode for TempestRemap
qnt_prc='' # [nbr] Quantization precision
rgr_opt='--rgr lat_nm_out=lat --rgr lon_nm_out=lon' # [sng] Regridding options
#rgr_opt='--rgr lat_dnm_nm=x --rgr lon_dmn_nm=y' # [sng] Regridding options for projection grid
rnr_thr='' # [frc] Renormalization option
se_np_nbr=4 # [nbr] Spectral Element polynomial order of discretization (for TempestRemap SE grids)
sgs_frc='' # [sng] Sub-grid fraction variable
sgs_frc_usr='' # [sng] Sub-grid fraction variable (user-defined)
sgs_msk='' # [sng] Sub-grid mask variable
sgs_nrm='1.0' # [frc] Sub-grid normalization
skl_fl='' # [sng] Skeleton file
std_chk='Yes' # [sng] Check stdin for input file list
std_flg='No' # [sng] Input available from pipe to stdin
stg_grd='No' # [flg] Include staggered grid variables
thr_nbr=2 # [nbr] Thread number for regridder
trn_map='No' # [flg] Tempest transpose map (i.e., fv2se_flx == monotr)
ugrid_fl='' # [sng] UGRID file
unq_sfx=".pid${spt_pid}" # [sng] Unique suffix
#var_lst='FSNT,AODVIS' # [sng] Variables to process (empty means all)
var_lst='' # [sng] Variables to process (empty means all)
var_rgr='' # [sng] CF template variable
var_xmp='FSNT' # [sng] Variable list for examples
vrb_lvl=${vrb_2} # [enm] Verbosity level
vrs_prn='No' # [sng] Print version information
vrt_in='' # [sng] Vertical grid file for input
vrt_nm='' # [sng] Vertical coordinate name
vrt_opt='' # [sng] Vertical options (e.g., '--rgr xtr_mth=mss_val')
vrt_out='' # [sng] Vertical grid file for output
vrt_ntp='' # [sng] Vertical interpolation type (lin|log)
vrt_xtr='' # [sng] Vertical extrapolation type (linear|mss_val|nrs_ngh|zero)
wgt_exe_cdo='cdo' # [sng] ESMF executable (weight generation only)
wgt_exe_esmf='ESMF_RegridWeightGen' # [sng] ESMF executable (weight generation only)
wgt_exe_mbt='mbtempest' # [sng] MOAB-Tempest executable (both mesh- and weight-generation)
wgt_exe_nco='ncks' # [sng] NCO executable (both mesh- and weight-generation)
wgt_exe_tps='GenerateOfflineMap' # [sng] TempestRemap weight-generation executable 
wgt_typ='' # [sng] Weight-generator program ('esmf', 'mbtempest', 'nco', or 'tempest')
wgt_opt='' # [sng] Weight-generator options
wgt_opt_cdo='' # [sng] CDO weight-generation options
wgt_opt_esmf='--no_log --ignore_unmapped' # [sng] ESMF_RegridWeightGen weight-generation options (ESMF < 7.1.0r). --ignore_unmapped tells ESMF to ignore cells on the destination grid which are not fully covered by cells on the source grid (because that would require extrapolation)
#wgt_opt_esmf='--ignore_unmapped --ignore_degenerate' # [sng] ESMF_RegridWeightGen weight-generation options (ESMF >= 7.1.0r) (ignore_degenerate is required for CICE regridding with ESMF >= 7.1.0r, and is not supported or required with ESMF < 7.1.0r)
wgt_opt_nco='-O --dmm_in_mk' # [sng] NCO weight-generation options
wgt_opt_tps='' # [sng] TempestRemap weight-generation options
msh_opt_tps='--allow_no_overlap' # [sng] TempestRemap mesh-generation options (20210421: add allow_no_overlap required by regional-to-regional grids like GrIS)
xcl_flg='No' # [sng] Exclude rather than extract variable list
xtn_var='' # [sng] Extensive variables (e.g., 'TSurfStd_ct')
xtr_nsp=8 # [nbr] Extrapolation number of source points (for ESMF & NCO only)
xtr_xpn=2.0 # [frc] Extrapolation inverse-distance exponent (absolute value) (for ESMF & NCO only)

# Set temporary-file directory (must be writable by user)
if [ -d "${TMPDIR}" ]; then
    # Fancy %/ syntax removes trailing slash (e.g., from $TMPDIR)
    drc_tmp="${TMPDIR%/}"
elif [ -d '/tmp' ]; then
    drc_tmp='/tmp'
else
    drc_tmp=${PWD}
fi # !gpfs

function fnc_usg_prn { # NB: dash supports fnc_nm (){} syntax, not function fnc_nm{} syntax
    # Print usage
    printf "${fnt_rvr}Basic usage:\n"
    printf "${fnt_nrm} ${fnt_bld}${spt_nm} --map=map.nc in_fl out_fl${fnt_nrm} # Apply existing map from in->out\n"
    printf "${fnt_nrm} ${fnt_bld}${spt_nm} -d dst_fl in_fl out_fl${fnt_nrm} # Construct map in->dst, regrid to out\n"
    printf "${fnt_nrm} ${fnt_bld}${spt_nm} --destination=dst_fl --input_file=in_fl --output_file=out_fl${fnt_nrm} # Long options (NB: '='is REQUIRED)\n\n"
    echo "Command-line options [long-option synonyms in ${fnt_tlc}italics${fnt_nrm}]:"
    echo "${fnt_rvr}-3${fnt_nrm}          Output file format ${fmt_sng_nc3} [${fnt_tlc}fl_fmt, file_format=classic${fnt_nrm}]"
    echo "${fnt_rvr}-4${fnt_nrm}          Output file format ${fmt_sng_nc4} [${fnt_tlc}fl_fmt, file_format=netcdf4${fnt_nrm}]"
    echo "${fnt_rvr}-5${fnt_nrm}          Output file format ${fmt_sng_nc5} [${fnt_tlc}fl_fmt, file_format=64bit_data${fnt_nrm}]"
    echo "${fnt_rvr}-6${fnt_nrm}          Output file format ${fmt_sng_nc6} [${fnt_tlc}fl_fmt, file_format=64bit_offset${fnt_nrm}]"
    echo "${fnt_rvr}-7${fnt_nrm}          Output file format ${fmt_sng_nc7} [${fnt_tlc}fl_fmt, file_format=netcdf4_classic${fnt_nrm}]"
    echo "${fnt_rvr}-a${fnt_nrm} ${fnt_bld}alg_typ${fnt_nrm}  Algorithm for weight generation (default ${fnt_bld}${alg_typ}${fnt_nrm}) [${fnt_tlc}alg_typ, algorithm, regrid_algorithm${fnt_nrm}]"
    echo "            CDO algorithms: cdo_bilinear|cdo_conservative (same as ESMF)"
    echo "            ESMF algorithms: esmfbilin,bilinear|esmfaave,aave,conserve|conserve2nd|nearestdtos|neareststod|patch"
    echo "            NCO algorithms: ncoaave,nco,nco_con|ncoidw,nco_dwe (inverse-distance-weighted interpolation/extrapolation)"
    echo "            Tempest (and MOAB-Tempest) algorithms: traave,fv2fv_flx|trbilin|trfv2|trintbilin|fv2fv|fv2fv_stt|fv2se_flx|fv2se_stt|fv2se_alt|se2fv_flx|se2fv_stt|se2fv_alt|se2se"
    echo " ${fnt_bld}--a2o${fnt_nrm}      Atmosphere-to-ocean remap (for Tempest only) (default ${fnt_bld}${a2o_flg}${fnt_nrm}) [${fnt_tlc}a2o, atm2ocn, b2l, big2ltl, l2s, lrg2sml${fnt_nrm}]"
    echo " ${fnt_bld}--add_fll${fnt_nrm}  Add _FillValue to fields with empty destination cells (default ${fnt_bld}${add_fll}${fnt_nrm}) [${fnt_tlc}add_fll, add_fill_value, fll_mpt, fill_empty${fnt_nrm}]"
    echo " ${fnt_bld}--alg_lst${fnt_nrm}  Algorithms to generate maps with in MWF mode (default ${fnt_bld}${alg_lst}${fnt_nrm}) [${fnt_tlc}alg_lst, algorithm_list${fnt_nrm}]"
    echo " ${fnt_bld}--area_dgn${fnt_nrm} Diagnose (rather than copy) grid_area to inferred grid-file (default ${fnt_bld}No${fnt_nrm}) [${fnt_tlc}area_diagnose, dgn_area, diagnose_area${fnt_nrm}]"
# 20220524: Implement but do not yet advertise codecs/CCR in ncremap
    echo " ${fnt_bld}--cmp_sng${fnt_nrm}  Compression string (empty means none) (default ${fnt_bld}${cmp_sng}${fnt_nrm}) [${fnt_tlc}cmp, cmp_sng, compress, compression, cpr, cdc, codec ${fnt_nrm}]"
    echo " ${fnt_bld}--col_dmn${fnt_nrm}  Column (unstructured) dimension name for coupler files (empty means none) (default ${fnt_bld}${col_dmn}${fnt_nrm}) [${fnt_tlc}col_dmn, col_nm, column_dimension, unstructured_dimension${fnt_nrm}]"
    echo "${fnt_rvr}-D${fnt_nrm} ${fnt_bld}dbg_lvl${fnt_nrm}  Debug level (default ${fnt_bld}${dbg_lvl}${fnt_nrm}) [${fnt_tlc}dbg_lvl, dbg, debug, debug_level${fnt_nrm}]"
    echo "${fnt_rvr}-d${fnt_nrm} ${fnt_bld}dst_fl${fnt_nrm}   Data file to infer destination grid from (empty means none, i.e., use grd_fl, grd_sng, or map_fl)) (default ${fnt_bld}${dst_fl}${fnt_nrm}) [${fnt_tlc}dst_fl, destination_file, tpl, tpl_fl, template, template_file${fnt_nrm}]"
    echo " ${fnt_bld}--d2f${fnt_nrm}      Convert double-precision fields to single-precision (default ${fnt_bld}${d2f_flg}${fnt_nrm}) [${fnt_tlc}d2f | d2s | dbl_flt | dbl_sgl | double_float${fnt_nrm}]"
    echo " ${fnt_bld}--devnull${fnt_nrm}  Send NCO weight-generator messages to /dev/null (default ${fnt_bld}${dvn_flg}${fnt_nrm}) [${fnt_tlc}devnull, dev_nll, dvn_flg${fnt_nrm}]"
    echo " ${fnt_bld}--dpt${fnt_nrm}      Add depth coordinate to MPAS files (default ${fnt_bld}${dpt_flg}${fnt_nrm}) [${fnt_tlc}dpt | depth | add_dpt | add_depth${fnt_nrm}]"
    echo " ${fnt_bld}--dpt_fl${fnt_nrm}   Depth file with refBottomDepth for MPAS ocean (empty means none) (default ${fnt_bld}${dpt_fl}${fnt_nrm}) [${fnt_tlc}dpt_fl, mpas_fl, mpas_depth, depth_file${fnt_nrm}]"
    echo " ${fnt_bld}--dpt_nm${fnt_nrm}   3D-Depth/height variable name (default ${fnt_bld}${dpt_nm}${fnt_nrm}) [${fnt_tlc}dpt_nm, depth_name, vrt_dpt${fnt_nrm}]"
    echo " ${fnt_bld}--dt_sng${fnt_nrm}   Date string (for MWF map names) (default ${fnt_bld}${dt_sng}${fnt_nrm}) [${fnt_tlc}dt_sng, date_string${fnt_nrm}]"
    echo " ${fnt_bld}--esmf_typ${fnt_nrm} ESMF Extrapolation type (empty means none) (default ${fnt_bld}${esmf_typ}${fnt_nrm}) [${fnt_tlc}esmf_typ, esmf_mth, esmf_extrap_type, esmf_extrap_method${fnt_nrm}] (nearestidavg|neareststod|none)"
    echo " ${fnt_bld}--fl_fmt${fnt_nrm}   File format (empty is netCDF3 64bit CDF2) (default ${fnt_bld}${fl_fmt}${fnt_nrm}) [${fnt_tlc}fl_fmt, fmt_out, file_format, format_out${fnt_nrm}]"
    echo "${fnt_rvr}-G${fnt_nrm} ${fnt_bld}grd_sng${fnt_nrm}  Grid generation arguments (empty means none) (default ${fnt_bld}${grd_sng}${fnt_nrm}) [${fnt_tlc}grd_sng, grid_generation, grid_gen, grid_string${fnt_nrm}]"
    echo "${fnt_rvr}-g${fnt_nrm} ${fnt_bld}grd_dst${fnt_nrm}  Grid-file (destination) (empty means none, i.e., infer from dst_fl or use map_fl) (default ${fnt_bld}${grd_dst}${fnt_nrm}) [${fnt_tlc}grd_dst, grid_dest, dst_grd, dest_grid, destination_grid${fnt_nrm}]"
    echo " ${fnt_bld}--gad_lst${fnt_nrm}  Global attributes to delete from output files (default ${fnt_bld}${gad_lst}${fnt_nrm}) [${fnt_tlc}gad, glb_att_del, att_del${fnt_nrm}]"
    echo " ${fnt_bld}--hrd_pth${fnt_nrm}  Use CSZ's hard-coded paths on known machines (e.g., chrysalis, compy, perlmutter) NB: Must be first option! [${fnt_tlc}hrd_pth, hard_path, npo, nco_path_override${fnt_nrm}]"
    echo "${fnt_rvr}-I${fnt_nrm} ${fnt_bld}drc_in${fnt_nrm}   Input directory (empty means none) (default ${fnt_bld}${drc_in}${fnt_nrm}) [${fnt_tlc}drc_in, in_drc, dir_in, in_dir, input${fnt_nrm}]"
    echo "${fnt_rvr}-i${fnt_nrm} ${fnt_bld}in_fl${fnt_nrm}    Input file (empty means pipe to stdin or drc_in) (default ${fnt_bld}${in_fl}${fnt_nrm}) [${fnt_tlc}in_fl, in_file, input_file${fnt_nrm}]"
    echo "${fnt_rvr}-j${fnt_nrm} ${fnt_bld}job_nbr${fnt_nrm}  Job simultaneity for parallelism (default ${fnt_bld}${job_nbr}${fnt_nrm}) [${fnt_tlc}job_nbr, job_number, jobs${fnt_nrm}]"
    echo "${fnt_rvr}-L${fnt_nrm} ${fnt_bld}dfl_lvl${fnt_nrm}  Deflate level (empty is none) (default ${fnt_bld}${dfl_lvl}${fnt_nrm}) [${fnt_tlc}dfl_lvl, dfl, deflate${fnt_nrm}]"
    echo "${fnt_rvr}-M${fnt_nrm}          Multi-map-file toggle (unset means generate one map-file per input file) [${fnt_tlc}mlt_map, no_multimap${fnt_nrm}]"
    echo "${fnt_rvr}-m${fnt_nrm} ${fnt_bld}map_fl${fnt_nrm}   Map-file (empty means generate internally) (default ${fnt_bld}${map_fl}${fnt_nrm}) [${fnt_tlc}map_fl, map, map_file, rgr_map, regrid_map${fnt_nrm}]"
    echo " ${fnt_bld}--mpi_nbr${fnt_nrm}  Number of tasks-per-node that MPI-enabled weight generators will request (default ${fnt_bld}${mpi_nbr}${fnt_nrm}) [${fnt_tlc}mpi_nbr, mpi_number, tsk_nbr, task_number${fnt_nrm}]"
    echo " ${fnt_bld}--mpi_pfx${fnt_nrm}  Prefix for MPI-enabled weight generators (empty means weight generator is not MPI-enabled) (default ${fnt_bld}${mpi_pfx}${fnt_nrm}) [${fnt_tlc}mpi_pfx, mpi_prefix, srun_cmd, srun_command${fnt_nrm}]"
    echo " ${fnt_bld}--mpt_mss${fnt_nrm}  Set empty (sgs_frc==0.0) SGS cells to missing value (default ${fnt_bld}${mpt_mss}${fnt_nrm}) [${fnt_tlc}mpt_mss, sgs_zro_mss$, empty_missing{fnt_nrm}]"
    echo " ${fnt_bld}--msh_fl${fnt_nrm}   Mesh-file for grid intersection (empty means generate internally or not at all) (default ${fnt_bld}${msh_fl}${fnt_nrm}) [${fnt_tlc}msh_fl, msh, mesh, mesh_file${fnt_nrm}]"
    echo " ${fnt_bld}--msk_apl${fnt_nrm}  Apply msk_out to variables after regridding (default ${fnt_bld}${msk_apl}${fnt_nrm}) [${fnt_tlc}msk_apl, mask_apply, msk_app${fnt_nrm}]"
    echo " ${fnt_bld}--msk_dst${fnt_nrm}  Mask-template variable in destination file (empty means none) (default ${fnt_bld}${msk_dst}${fnt_nrm}) [${fnt_tlc}msk_dst, dst_msk, mask_destination, mask_dst${fnt_nrm}]"
    echo " ${fnt_bld}--msk_out${fnt_nrm}  Put mask variable in regridded file, argument is name (default ${fnt_bld}${msk_out}${fnt_nrm}) [${fnt_tlc}msk_out, out_msk, mask_output, mask_rgr${fnt_nrm}]"
    echo " ${fnt_bld}--msk_src${fnt_nrm}  Mask-template variable in source file (empty means none) (default ${fnt_bld}${msk_src}${fnt_nrm}) [${fnt_tlc}msk_src, src_msk, mask_source, mask_src${fnt_nrm}]"
    echo " ${fnt_bld}--mss_val${fnt_nrm}  Missing value for MPAS (empty means none) (default ${fnt_bld}${mss_val}${fnt_nrm}) [${fnt_tlc}mss_val, fll_val, missing_value, fill_value${fnt_nrm}]"
    echo "${fnt_rvr}-n${fnt_nrm} ${fnt_bld}nco_opt${fnt_nrm}  NCO options (empty means none) (default ${fnt_bld}${nco_opt}${fnt_nrm}) [${fnt_tlc}nco_opt, nco_options${fnt_nrm}]"
    echo " ${fnt_bld}--nm_dst${fnt_nrm}   Short name of destination grid (required for MWF, no default) [${fnt_tlc}nm_dst, name_dst, nm_sht_dst, short_name_destination${fnt_nrm}]"
    echo " ${fnt_bld}--nm_src${fnt_nrm}   Short name of source grid (required for MWF, no default) [${fnt_tlc}nm_src, name_src, nm_sht_src, short_name_source${fnt_nrm}]"
    echo " ${fnt_bld}--no_add_fll${fnt_nrm}  Do not add _FillValue to fields with empty destination cells [${fnt_tlc}no_add_fll, no_add_fill_value, no_fll_mpt, no_fill_empty${fnt_nrm}]"
    echo " ${fnt_bld}--no_cll_msr${fnt_nrm}  Omit cell_measures variables (e.g., 'area') [${fnt_tlc}no_area, no_cll_msr, no_cell_measures${fnt_nrm}]"
    echo " ${fnt_bld}--no_frm_trm${fnt_nrm}  Omit formula_terms variables (e.g., 'hyba', 'PS') [${fnt_tlc}no_frm_trm, no_formula_terms${fnt_nrm}]"
    echo " ${fnt_bld}--no_permute${fnt_nrm}  Do not permute dimensions before regridding [${fnt_tlc}no_prm, no_pdq, no_ncpdq${fnt_nrm}]"
    echo " ${fnt_bld}--no_stg_grd${fnt_nrm}  Omit staggered grid variables ('slat, slon, w_stag') (default ${fnt_bld}True${fnt_nrm}) [${fnt_tlc}no_stg_grd, no_stg, no_stagger, no_staggered_grid${fnt_nrm}]"
    echo " ${fnt_bld}--no_stdin${fnt_nrm} Do not check stdin for input file list [${fnt_tlc}no_stdin, no_inp_std, no_redirect, no_standard_input${fnt_nrm}]"
    echo " ${fnt_bld}--nsx_alg${fnt_nrm}  Intersection algorithm used by mbtempest (default ${fnt_bld}kdtree${fnt_nrm}) [${fnt_tlc}nsx_alg, intersection_algorithm${fnt_nrm}] (advfront|kdtree)"
    echo "${fnt_rvr}-O${fnt_nrm} ${fnt_bld}drc_out${fnt_nrm}  Output directory (default ${fnt_bld}${drc_out}${fnt_nrm}) [${fnt_tlc}drc_out, out_drc, dir_out, out_dir, output${fnt_nrm}]"
    echo "${fnt_rvr}-o${fnt_nrm} ${fnt_bld}out_fl${fnt_nrm}   Output-file (regridded file) (empty copies Input filename) (default ${fnt_bld}${out_fl}${fnt_nrm}) [${fnt_tlc}out_fl, out_file, output_file${fnt_nrm}]"
    echo "${fnt_rvr}-P${fnt_nrm} ${fnt_bld}prc_typ${fnt_nrm}  Procedure type (empty means none) (default ${fnt_bld}${prc_typ}${fnt_nrm}) [${fnt_tlc}prc_typ, prm_typ, procedure${fnt_nrm}] (cpl|eam|eamxx|elm|mpasa|mpaso|mpassi|cam|clm|pop|...)"
    echo "${fnt_rvr}-p${fnt_nrm} ${fnt_bld}par_typ${fnt_nrm}  Parallelism type (default ${fnt_bld}${par_typ}${fnt_nrm}) [${fnt_tlc}par_typ, par_md, parallel_type, parallel_mode, parallel${fnt_nrm}]"
    echo " ${fnt_bld}--pdq_opt${fnt_nrm}  ncpdq dimension permutation string (empty means none) (default ${fnt_bld}${pdq_opt}${fnt_nrm}) [${fnt_tlc}pdq, pdq_opt, prm, prm_opt, permute${fnt_nrm}]"
    echo " ${fnt_bld}--preserve${fnt_nrm} Preserved statistic (empty preserves integral, except mean for MPAS) (default ${fnt_bld}${prs_stt}${fnt_nrm}) [${fnt_tlc}preserve, prs_stt, preserved_statistic${fnt_nrm}] (integral|mean)"
    echo " ${fnt_bld}--prt_nbr${fnt_nrm}  Partition number for MOAB parallelism (default ${fnt_bld}${prt_nbr}${fnt_nrm}) [${fnt_tlc}prt_nbr, prt, partition_number${fnt_nrm}]"
    echo " ${fnt_bld}--ps_nm${fnt_nrm}    Surface pressure variable name (default ${fnt_bld}${ps_nm_dfl}${fnt_nrm}) [${fnt_tlc}ps_nm, ps_name, ps, vrt_ps${fnt_nrm}]"
    echo " ${fnt_bld}--ps_rtn${fnt_nrm}   Retain surface pressure after vertical interpolation (default ${fnt_bld}${ps_rtn}${fnt_nrm}) [${fnt_tlc}ps_rtn, rtn_sfc_prs, retain_surface_pressure${fnt_nrm}]"
#    echo " ${fnt_bld}--qea_flg${fnt_nrm}  Quasi-equal area mode for TempestRemap (default ${fnt_bld}${qea_flg}${fnt_nrm}) [${fnt_tlc}qea, qea_flg, np2, quasi-equal-area${fnt_nrm}]"
    echo " ${fnt_bld}--qnt_prc${fnt_nrm}  Quantization precision (empty means none) (default ${fnt_bld}${qnt_prc}${fnt_nrm}) [${fnt_tlc}qnt, qnt_prc, ppc, ppc_prc, precision, quantize${fnt_nrm}]"
    echo "${fnt_rvr}-R${fnt_nrm} ${fnt_bld}rgr_opt${fnt_nrm}  Regrid options (empty means none) (default ${fnt_bld}${rgr_opt}${fnt_nrm}) [${fnt_tlc}rgr_opt, regrid_options${fnt_nrm}]"
    echo "${fnt_rvr}-r${fnt_nrm} ${fnt_bld}rnr_thr${fnt_nrm}  Renormalization threshold (empty means none (except for MPAS, see documentation)) (default ${fnt_bld}${rnr_thr}${fnt_nrm}) [${fnt_tlc}rnr_thr, rnr, renormalize, renormalization_threshold${fnt_nrm}]"
    echo " ${fnt_bld}--rgn_dst${fnt_nrm}  Regional destination grid [${fnt_tlc}rgn_dst, dst_rgn, regional_destination${fnt_nrm}]"
    echo " ${fnt_bld}--rgn_src${fnt_nrm}  Regional source grid [${fnt_tlc}rgn_src, src_rgn, regional_source${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_bb_wesn${fnt_nrm}  Regional regridding bounding-box WESN order (empty means none) (default ${fnt_bld}${bb_wesn}${fnt_nrm}) [${fnt_tlc}rrg_bb_wesn, bb, bb_wesn, wesn_sng${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_dat_glb${fnt_nrm}  Regional regridding global data file (empty means none) (default ${fnt_bld}${dat_glb}${fnt_nrm}) [${fnt_tlc}rrg_dat_glb, dat_glb, data_global, global_data${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_grd_glb${fnt_nrm}  Regional regridding global grid file (empty means none) (default ${fnt_bld}${grd_glb}${fnt_nrm}) [${fnt_tlc}rrg_grd_glb, grd_glb, grid_global, global_grid${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_grd_rgn${fnt_nrm}  Regional regridding regional grid file (empty means none) (default ${fnt_bld}${grd_rgn}${fnt_nrm}) [${fnt_tlc}rrg_grd_rgn, grd_rgn, grid_regional, regional_grid${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_rnm_sng${fnt_nrm}  Regional regridding rename string (empty means none) (default ${fnt_bld}${rnm_sng}${fnt_nrm}) [${fnt_tlc}rrg_rnm_sng, rnm_sng, rename_string${fnt_nrm}]"
    echo "${fnt_rvr}-s${fnt_nrm} ${fnt_bld}grd_src${fnt_nrm}  Grid-file (source) (empty means infer or use map_fl) (default ${fnt_bld}${grd_src}${fnt_nrm}) [${fnt_tlc}grd_src, grid_source, source_grid, src_grd${fnt_nrm}]"
    echo " ${fnt_bld}--sgs_frc${fnt_nrm}  Sub-grid fraction variable (empty means none) (default ${fnt_bld}${sgs_frc}${fnt_nrm}) [${fnt_tlc}sgs_frc, ice_frc, lnd_frc, ocn_frc, subgrid_fraction${fnt_nrm}]"
    echo " ${fnt_bld}--sgs_msk${fnt_nrm}  Sub-grid mask variable (empty means none) (default ${fnt_bld}${sgs_msk}${fnt_nrm}) [${fnt_tlc}sgs_msk, ice_msk, lnd_msk, ocn_msk, subgrid_mask${fnt_nrm}]"
    echo " ${fnt_bld}--sgs_nrm${fnt_nrm}  Sub-grid fraction normalization (empty means none) (default ${fnt_bld}${sgs_nrm}${fnt_nrm}) [${fnt_tlc}sgs_nrm, subgrid_normalization${fnt_nrm}]"
    echo " ${fnt_bld}--skl_fl${fnt_nrm}   Skeleton file (empty means none) (default ${fnt_bld}${skl_fl}${fnt_nrm}) [${fnt_tlc}skl_fl, skl, skeleton, skeleton_file${fnt_nrm}]"
    echo " ${fnt_bld}--std_flg${fnt_nrm}  Stdin used for input (default ${fnt_bld}${inp_std}${fnt_nrm}) [${fnt_tlc}stdin, std_flg, inp_std, redirect, standard_input${fnt_nrm}]"
    echo " ${fnt_bld}--stg_grd${fnt_nrm}  Add staggered grid variables ('slat, slon, w_stag') (default ${fnt_bld}False${fnt_nrm}) [${fnt_tlc}stg_grd, stg, stagger, staggered_grid${fnt_nrm}]"
    echo "${fnt_rvr}-T${fnt_nrm} ${fnt_bld}drc_tmp${fnt_nrm}  Temporary directory (for intermediate files) (default ${fnt_bld}${drc_tmp}${fnt_nrm}) [${fnt_tlc}drc_tmp, tmp_drc, dir_tmp, tmp_dir, tmp${fnt_nrm}]"
    echo "${fnt_rvr}-t${fnt_nrm} ${fnt_bld}thr_nbr${fnt_nrm}  Thread number for regridder (default ${fnt_bld}${thr_nbr}${fnt_nrm}) [${fnt_tlc}thr_nbr, thr, thread_number, thread, threads${fnt_nrm}]"
    echo "${fnt_rvr}-U${fnt_nrm}          Unpack input prior to regridding [${fnt_tlc}unpack, upk, upk_inp${fnt_nrm}]"
    echo "${fnt_rvr}-u${fnt_nrm} ${fnt_bld}unq_sfx${fnt_nrm}  Unique suffix (prevents intermediate files from sharing names) (default ${fnt_bld}${unq_sfx}${fnt_nrm}) [${fnt_tlc}unq_sfx, unique_suffix, suffix${fnt_nrm}]"
    echo " ${fnt_bld}--ugrid_fl${fnt_nrm} UGRID file (empty means none) (default ${fnt_bld}${ugrid_fl}${fnt_nrm}) [${fnt_tlc}ugrid_fl, ugrid, ugrid_file${fnt_nrm}]"
    echo " ${fnt_bld}--uio${fnt_nrm}      Unbuffered I/O (NC_SHARE) for netCDF3 files [${fnt_tlc}uio, unbuffered, share${fnt_nrm}]"
    echo "${fnt_rvr}-V${fnt_nrm} ${fnt_bld}var_rgr${fnt_nrm}  CF template variable (empty means none) (default ${fnt_bld}${var_rgr}${fnt_nrm}) [${fnt_tlc}var_rgr, rgr_var, var_cf, cf_var, cf_variable${fnt_nrm}]"
    echo "${fnt_rvr}-v${fnt_nrm} ${fnt_bld}var_lst${fnt_nrm}  Variable list (empty means all) (default ${fnt_bld}${var_lst}${fnt_nrm}) [${fnt_tlc}var_lst, variable_list, var, vars, variable, variables${fnt_nrm}]"
    echo " ${fnt_bld}--version${fnt_nrm}  Version and configuration information [${fnt_tlc}version, vrs, config, configuration, cnf${fnt_nrm}]"
    echo " ${fnt_bld}--vrb_lvl${fnt_nrm}  Verbosity level (default ${fnt_bld}${vrb_lvl}${fnt_nrm}) [${fnt_tlc}vrb_lvl, vrb, verbosity, print_verbosity${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_in${fnt_nrm}   Vertical grid file for input (empty means none) (default ${fnt_bld}${vrt_in}${fnt_nrm}) [${fnt_tlc}vrt_in, vrt_grd_in${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_nm${fnt_nrm}   Vertical coordinate name (empty means \"plev\") (default ${fnt_bld}${vrt_nm}${fnt_nrm}) [${fnt_tlc}vrt_nm, plev_nm, vrt_crd, vertical_coordinate_name${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_ntp${fnt_nrm}  Vertical interpolation type (empty means none) (default ${fnt_bld}${vrt_ntp}${fnt_nrm}) [${fnt_tlc}vrt_ntp, ntp_mth, interpolation_type, interpolation_method${fnt_nrm}] (lin|log)"
    echo " ${fnt_bld}--vrt_out${fnt_nrm}  Vertical grid file for output (empty means none) (default ${fnt_bld}${vrt_out}${fnt_nrm}) [${fnt_tlc}vrt_out, vrt_fl, vrt, vrt_grd_out${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_xtr${fnt_nrm}  Vertical extrapolation type (empty means none) (default ${fnt_bld}nrs_ngh${fnt_nrm}) [${fnt_tlc}vrt_xtr, xtr_mth, extrapolation_type, extrapolation_method${fnt_nrm}] (linear|mss_val|nrs_ngh|zero)"
    echo "${fnt_rvr}-W${fnt_nrm} ${fnt_bld}wgt_opt${fnt_nrm}  Weight-generator options (default ${fnt_bld}${wgt_opt_esmf}${fnt_nrm}) [${fnt_tlc}wgt_opt, esmf_opt, esmf_options, tempest_opt, tps_opt${fnt_nrm}]"
    echo "${fnt_rvr}-w${fnt_nrm} ${fnt_bld}wgt_cmd${fnt_nrm}  Weight-generator command (default ${fnt_bld}${wgt_exe_esmf}${fnt_nrm}) [${fnt_tlc}wgt_cmd, wgt_gnr, weight_command, weight_generator${fnt_nrm}]"
    echo "${fnt_rvr}-x${fnt_nrm} ${fnt_bld}xtn_var${fnt_nrm}  Extensive variables (empty means none) (default ${fnt_bld}${xtn_var}${fnt_nrm}) [${fnt_tlc}xtn_var, xtn_lst, extensive, var_xtn, extensive_variables${fnt_nrm}]"
    echo " ${fnt_bld}--xcl_var${fnt_nrm}  Exclude rather than extract var_lst [${fnt_tlc}xcl_var, xcl, exclude, exclude_variables${fnt_nrm}]"
    echo " ${fnt_bld}--xtr_nsp${fnt_nrm}  Extrapolation number of source points (for ESMF & NCO only) (default ${fnt_bld}${xtr_nsp}${fnt_nrm}) [${fnt_tlc}xtr_nsp, xtr_pnt_src_nbr, extrap_num_src_pnts${fnt_nrm}]"
    echo " ${fnt_bld}--xtr_xpn${fnt_nrm}  Extrapolation inverse-distance exponent (for ESMF & NCO only) (default ${fnt_bld}${xtr_xpn}${fnt_nrm}) [${fnt_tlc}xtr_xpn, xtr_dst_xpn, extrap_dist_exponent${fnt_nrm}]"
    printf "\n"
    printf "Examples: ${fnt_bld}${spt_nm} -m ${map_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -s ${grd_src_xmp} -g ${grd_dst_xmp} -m ${map_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -d ${dst_xmp} -g ${grd_dst_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a esmfaave  -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a esmfbilin -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a ncoaave   -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a traave    -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a trbilin   -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a trfv2     -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -a trintbilin -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -v ${var_xmp} -m ${map_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -m ${map_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -M -d ${dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -M -g ${grd_dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -s ${grd_src_xmp} -d ${dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -d ${dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} -g ${grd_dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} --vrt_out=${grd_vrt_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}${spt_nm} --vrt_out=${grd_vrt_xmp} -m ${map_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}ls mdl*2005*nc | ${spt_nm} -m ${map_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}ls mdl*2005*nc | ${spt_nm} -d ${dst_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "\nComplete documentation at http://nco.sf.net/nco.html#${spt_nm}\n\n"
    exit 1
} # !fnc_usg_prn()

# RRG processing needs NCO filters documented in http://nco.sf.net/nco.html#filter
function ncvarlst { ncks --trd -m ${1} | grep -E ': type' | cut -f 1 -d ' ' | sed 's/://' | sort ; }
function ncdmnlst { ncks --cdl -m ${1} | cut -d ':' -f 1 | cut -d '=' -s -f 1 ; }
function nchasvar { ncks --trd -C -m -v ${1} ${2} | grep -E ': type' | cut -f 1 -d ' ' | sed 's/://' ; }

function dst_is_grd {
    # Purpose: Is destination grid specified as SCRIP grid-file?
    # fxm: Not working yet
    # Figure-out whether data-file or grid-file and proceed accordingly
    # Allow ncremap to combine -d and -g switches
    # Usage: dst_is_grd ${fl}
    fl=${1}
    flg='Yes'
    #flg='No'
} # !dst_is_grd()

# Check argument number and complain accordingly
arg_nbr=$#
if [ ${arg_nbr} -eq 0 ]; then
  fnc_usg_prn
fi # !arg_nbr

# Parse command-line options:
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options
# http://tuxtweaks.com/2014/05/bash-getopts
while getopts :34567a:CD:d:f:g:G:h:I:i:j:L:Mm:n:O:o:P:p:R:r:s:T:t:Uu:V:v:W:w:x:-: OPT; do
    case ${OPT} in
	3) fl_fmt='3' ;; # File format
	4) fl_fmt='4' ;; # File format
	5) fl_fmt='5' ;; # File format
	6) fl_fmt='6' ;; # File format
	7) fl_fmt='7' ;; # File format
	a) alg_typ="${OPTARG}" ;; # Algorithm
	C) clm_flg='Yes' ;; # Climo flag (undocumented)
	D) dbg_lvl="${OPTARG}" ;; # Debugging level
	d) dst_fl="${OPTARG}" ;; # Destination file
	g) grd_dst="${OPTARG}" ;; # Destination grid-file
	G) grd_sng="${OPTARG}" ;; # Grid generation string
	I) drc_in="${OPTARG}" ;; # Input directory
	i) in_fl="${OPTARG}" ;; # Input file
	j) job_usr="${OPTARG}" ;; # Job simultaneity
	L) dfl_lvl="${OPTARG}" ;; # Deflate level
	M) mlt_map_flg='No' ;; # Multi-map flag
	m) map_fl="${OPTARG}" ;; # Map-file
	n) nco_opt="${OPTARG} ${nco_opt}" ;; # NCO options
	O) drc_usr="${OPTARG}" ;; # Output directory
	o) out_fl="${OPTARG}" ;; # Output file
	P) prc_typ="${OPTARG}" ;; # Procedure type
	p) par_typ="${OPTARG}" ;; # Parallelism type
	r) rnr_thr="${OPTARG}" ;; # Renormalization threshold
	R) rgr_opt="${OPTARG}" ;; # Regridding options
	s) grd_src="${OPTARG}" ;; # Source grid-file
	T) tmp_usr="${OPTARG}" ;; # Temporary directory
	t) thr_usr="${OPTARG}" ;; # Thread number
	U) pdq_opt='-U' ;;        # Unpack input
	u) unq_usr="${OPTARG}" ;; # Unique suffix
	V) var_rgr="${OPTARG}" ;; # CF template variable 
	v) var_lst="${OPTARG}" ;; # Variables
	W) wgt_opt_usr="${OPTARG}" ;; # Weight-generator options
	w) wgt_usr="${OPTARG}" ;; # Weight-generator command
	x) xtn_var="${OPTARG}" ;; # Extensive variables
	-) LONG_OPTARG="${OPTARG#*=}"
	   case ${OPTARG} in
	       # Hereafter ${OPTARG} is long argument key, and ${LONG_OPTARG}, if any, is long argument value
	       # Long options with no argument, no short option counterpart
	       # Long options with argument, no short option counterpart
	       # Long options with short counterparts, ordered by short option key
	       a2o | atm2ocn | b2l | big2ltl | l2s | lrg2sml ) a2o_flg='Yes' ;; # # Atmosphere-to-ocean
	       a2o=?* | atm2ocn=?* | b2l=?* | big2ltl=?* | l2s=?* | lrg2sml=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Atmosphere-to-ocean
	       add_fll | add_fill_value | fll_mpt | fill_empty ) add_fll_usr='Yes' ;; # # Add _FillValue to fields with empty destination cells
	       add_fll=?* | add_fill_value=?* | fll_mpt=?* | fill_empty=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Add _FillValue to fields with empty destination cells
	       no_add_fll | no_add_fill_value | no_fll_mpt | no_fill_empty ) add_fll_usr='No' ;; # # Do not add _FillValue to fields with empty destination cells
	       no_add_fll=?* | no_add_fill_value=?* | no_fll_mpt=?* | fill_empty=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Do not add _FillValue to fields with empty destination cells
	       alg_lst=?* | algorithm_list=?* ) alg_lst="${LONG_OPTARG}" ;; # # Algorithm list for MWF mode
	       alg_typ=?* | algorithm=?* | regrid_algorithm=?* ) alg_typ="${LONG_OPTARG}" ;; # -a # Algorithm
	       area_dgn | dgn_area | area_diagnose | diagnose_area ) area_dgn='Yes' ;; # # Diagnose (rather than copy) grid_area to inferred grid-file
	       area_dgn=?* | dgn_area=?* | area_diagnose=?* | diagnose_area=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Diagnose (rather than copy) grid_area in inferred grids
	       clm_flg | climatology_flag ) clm_flg='Yes' ;; # -C # Climo flag (undocumented)
	       clm_flg=?* | climatology_flag=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # clm_flg
	       cmp=?* | cmp_sng=?* | compress=? | compression=?* | cpr=?* | cdc=?* | codec=?* ) cmp_sng="${LONG_OPTARG}" ;; # # Compression string
	       col_dmn=?* | col_nm=?* | column_dimension=? | unstructured_dimension=? ) col_dmn="${LONG_OPTARG}" ;; # # Column (unstructured) dimension name for coupler files
	       d2f | d2s | dbl_flt | dbl_sgl | double_float ) d2f_flg='Yes' ;; # # Convert double-precision fields to single-precision
	       d2f=?* | d2s=?* | dbl_flt=?* | dbl_sgl=?* | double_float=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # D2F
	       dbg_lvl=?* | dbg=?* | debug=?* | debug_level=?* ) dbg_lvl="${LONG_OPTARG}" ;; # -d # Debugging level
	       devnull=?* | dev_nll=?* | dev_null=?* | dvn_flg=?* ) dvn_flg="${LONG_OPTARG}" ;; # # Send NCO weight-generator messages to /dev/null
	       dfl_lvl=?* | deflate=?* | dfl=?* ) dfl_lvl="${LONG_OPTARG}" ;; # -L # Deflate level
	       dpt | depth | add_dpt | add_depth ) dpt_flg='Yes' ;; # # Add depth coordinate to MPAS files
	       dpt=?* | depth=?* | add_dpt=?* | add_depth=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # DPT
	       dpt_fl=?* | mpas_fl=?* | mpas_file=?* | depth_file=?* ) dpt_fl="${LONG_OPTARG}" ;; # # Depth file with refBottomDepth for MPAS ocean
	       dpt_nm=?* | depth_name=?* | vrt_dpt=?* ) dpt_nm="${LONG_OPTARG}" ;; # # 3D-depth/height variable name
	       dst_fl=?* | destination_file=?* | tpl=?* | tpl_fl=?* | template=?* | template_file=?* ) dst_fl="${LONG_OPTARG}" ;; # -d # Destination file
	       grd_dst=?* | grid_dest=?* | dst_grd=?* | dest_grid=?* | destination_grid=?* ) grd_dst="${LONG_OPTARG}" ;; # -g # Destination grid-file
	       grd_sng=?* | grid_generation=?* | grid_gen=?* | grid_string=?* ) grd_sng="${LONG_OPTARG}" ;; # -G # Grid generation string
	       drc_in=?* | in_drc=?* | dir_in=?* | in_dir=?* | input=?* ) drc_in="${LONG_OPTARG}" ;; # -i # Input directory
	       dt_sng=?* | date_string=?* ) dt_sng="${LONG_OPTARG}" ;; # # Date string for MWF map names
	       esmf_typ=?* | esmf_mth=?* | esmf_extrap_type=?* | esmf_extrap_method=?* ) esmf_typ="${LONG_OPTARG}" ;; # # ESMF extrapolation type (nearestidavg|neareststod|none)
	       fl_fmt=?* | fmt_out=?* | file_format=?* | format_out=?* ) fl_fmt="${LONG_OPTARG}" ;; # # Output file format
	       gad_lst=?* | gad=?* | att_del=?* | glb_att_del=?* ) gad_sng="--glb_att_del=${LONG_OPTARG}" ;; # # Global attributes to delete
	       hrd_pth | hard_path | npo | nco_path_override | NCO_PATH_OVERRIDE ) hrd_pth='Yes' ;; # # Use hard-coded paths on known machines (intentional no-op because already handled prior to getopt())
	       hrd_pth=?* | hard_path=?* | npo=?* | nco_path_override=?* | NCO_PATH_OVERRIDE=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Use hard-coded paths on known machines
	       in_fl=?* | in_file=?* | input_file=?* ) in_fl="${LONG_OPTARG}" ;; # -i # Input file
	       job_nbr=?* | job_number=?* | jobs=?* ) job_usr="${LONG_OPTARG}" ;; # -j # Job simultaneity
	       map_fl=?* | map=?* | map_file=?* | rgr_map=?* | regrid_map=?* ) map_fl="${LONG_OPTARG}" ;; # -m # Map-file
	       mem_mb=?* ) mem_mb="${LONG_OPTARG}" ;; # # Megabytes of RAM per srun job in Cori SLURM in MPI mode
	       mlt_map | multimap | no_multimap | nomultimap ) mlt_map_flg='No' ;; # -M # Multi-map flag
	       mlt_map=?* | multimap=?* | no_multimap=?* | nomultimap=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # -M # Multi-map flag
	       mpi_nbr=?* | mpi_number=?* | tsk_nbr=?* | task_number=?* ) mpi_nbr_usr="${LONG_OPTARG}" ;; # # Number of tasks-per-node that MPI-enabled weight generators will request
	       mpi_pfx=?* | mpi_prefix=?* | srun_cmd=?* | srun_command=?* ) mpi_pfx_usr="${LONG_OPTARG}" ;; # # Prefix for MPI-enabled weight generators
	       mpt_mss | sgs_zro_mss | empty_missing ) mpt_mss='Yes' ;; # # Set empty (sgs_frc==0.0) SGS cells to missing value
	       mpt_mss=?* | sgs_zro_mss=?* | empty_missing=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Set empty (sgs_frc==0.0) SGS cells to missing value
	       msh_fl=?* | msh=?* | mesh=?* | mesh_file=?* ) msh_fl="${LONG_OPTARG}" ;; # # Mesh file
	       msk_apl | mask_apply | msk_app ) msk_apl='Yes' ;; # # Apply msk_out to variables after regridding
	       msk_apl=?* | mask_apply=?* | msk_app=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Apply msk_out to variables after regridding
	       msk_dst=?* | dst_msk=?* | mask_destination=?* | mask_dst=?* ) msk_dst="${LONG_OPTARG}" ;; # # Mask-template variable in destination file
	       msk_out=?* | out_msk=?* | mask_output=?* | mask_out=?* ) msk_out="${LONG_OPTARG}" ;; # # Put mask variable in regridded file, argument is name
	       msk_src=?* | src_msk=?* | mask_source=?* | mask_src=?* ) msk_src="${LONG_OPTARG}" ;; # # Mask-template variable in source file
	       mss_val=?* | fll_val=?* | missing_value=?* | fill_value=?* ) mss_val_usr="${LONG_OPTARG}" ;; # # Missing value for MPAS
	       nco_opt=?* | nco=?* | nco_options=?* ) nco_opt="${LONG_OPTARG} ${nco_opt}" ;; # -n # NCO options
	       nm_dst=?* | name_dst=?* | nm_sht_dst=?* | short_name_destination=?* ) nm_dst="${LONG_OPTARG}" ;; # # Short name of destination grid
	       nm_src=?* | name_src=?* | nm_sht_src=?* | short_name_source=?* ) nm_src="${LONG_OPTARG}" ;; # # Short name of source grid
	       no_area | no_cll_msr | no_cell_measures ) no_cll_msr='Yes' ;; # # Omit cell_measures variables
	       no_area=?* | no_cell_msr=?* | no_cell_measures=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Omit cell_measures variables
	       no_frm_trm | no_frm | no_formula_terms ) no_frm_trm='Yes' ;; # # Omit formula_terms variables
	       no_frm_trm=?* | no_frm=?* | no_formula_terms=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Omit formula_terms variables
	       no_permute | no_prm | no_pdq | no_ncpdq ) pdq_flg='No' ;; # # Do not permute dimensions before regridding
	       no_permute=?* | no_prm=?* | no_pdq=?* | no_ncpdq=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Do not permute dimensions before regridding
	       nsx_alg=?* | intersection_algorithm=?* ) nsx_alg="${LONG_OPTARG}" ;; # # Intersection algorithm used by mbtempest
	       drc_out=?* | out_drc=?* | dir_out=?* | out_dir=?* | output=?* ) drc_usr="${LONG_OPTARG}" ;; # -O # Output directory
	       out_fl=?* | output_file=?* | out_file=?* ) out_fl="${LONG_OPTARG}" ;; # -o # Output file
	       prc_typ=?* | prm_typ=?* | procedure=?* ) prc_typ="${LONG_OPTARG}" ;; # -P # Procedure type
	       par_typ=?* | par_md=?* | parallel_type=?* | parallel_mode=?* | parallel=?* ) par_typ="${LONG_OPTARG}" ;; # -p # Parallelism type
	       pdq=?* | prm=?* | pdq_opt=?* | prm_opt=?* | permute=?* ) pdq_opt="-a ${LONG_OPTARG}" ;; # # ncpdq dimension permutation option
	       qnt=?* | qnt_prc=?* | precision=?* | ppc=?* | ppc_prc=?* | quantize=?* ) qnt_prc="${LONG_OPTARG}" ;; # # Quantization precision
	       prs_stt=?* | preserve=?* | preserved_statistic=?* ) prs_stt_usr="${LONG_OPTARG}" ;; # # Preserved statistic
	       prt=?* | prt_nbr=?* | partition_number=?* ) prt_nbr="${LONG_OPTARG}" ;; # # Partition number for MOAB parallelism
	       ps_nm=?* | ps_name=?* | ps=?* | vrt_ps=?* ) ps_nm="${LONG_OPTARG}" ;; # # Surface pressure variable name
	       ps_rtn | rtn_sfc_prs | retain_surface_pressure ) ps_rtn='Yes' ;; # # Retain surface pressure variable in vertical interpolation output
	       ps_rtn=?* | rtn_sfc_prs=?* | retain_surface_pressure=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Retain surface pressure variable in vertical interpolation output
	       qea | qea_flg | np2 | quasi-equal-area ) qea_flg='Yes' ;; # # Quasi-equal area mode for TempestRemap
	       qea=?* | qea_flg=?* | np2=?* | quasi-equal-area=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Quasi-equal area mode for TempestRemap
	       rgr_opt=?* | regrid_options=?* ) rgr_opt="${LONG_OPTARG}" ;; # -R # Regridding options
	       rnr_thr=?* | thr_rnr=?* | rnr=?* | renormalize=?* | renormalization_threshold=?* ) rnr_thr="${LONG_OPTARG}" ;; # -r # Renormalization threshold
	       rgn_dst=?* | dst_rgn=?* | regional_destination=?* ) hnt_dst='--dst_regional' ;; # # Regional destination grid
	       rgn_dst=?* | dst_rgn=?* | regional_destination=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Regional destination grid
	       rgn_src=?* | src_rgn=?* | regional_source=?* ) hnt_src='--src_regional' ;; # # Regional source grid
	       rgn_src=?* | src_rgn=?* | regional_source=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Regional source grid
	       rrg_bb_wesn=?* | bb_wesn=?* | bb=?* | bounding_box=?* ) bb_wesn="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding bounding-box WESN order
	       rrg_dat_glb=?* | dat_glb=?* | data_global=?* | global_data=?* ) dat_glb="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding global data file
	       rrg_grd_glb=?* | grd_glb=?* | grid_global=?* | global_grid=?* ) grd_glb="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding global grid file
	       rrg_grd_rgn=?* | grd_rgn=?* | grid_regional=?* | regional_grid=?* ) grd_rgn="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding regional grid file
	       rrg_rnm_sng=?* | rnm_sng=?* | rename_string=?* ) rnm_sng="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding rename string
	       grd_src=?* | grid_source=?* | source_grid=?* | src_grd=?* ) grd_src="${LONG_OPTARG}" ;; # -s # Source grid-file
	       sgs_frc=?* | ice_frc=?* | lnd_frc=?* | ocn_frc=?* | subgrid_fraction=?* ) sgs_frc_usr="${LONG_OPTARG}" ;; # # Sub-grid fraction variable
	       sgs_msk=?* | ice_msk=?* | lnd_msk=?* | ocn_msk=?* | subgrid_mask=?* ) sgs_msk="${LONG_OPTARG}" ;; # # Sub-grid mask variable
	       sgs_nrm=?* | subgrid_normalization=?* ) sgs_nrm="${LONG_OPTARG}" ;; # # Sub-grid fraction normalization
	       skl_fl=?* | skl=?* | skeleton=?* | skeleton_file=?* ) skl_fl="${LONG_OPTARG}" ;; # # Skeleton file
	       stdin | inp_std | std_flg | redirect | standard_input ) inp_std='Yes' ;; # # Input file list from stdin
	       stdin=?* | inp_std=?* | std_flg=?* | redirect=?* | standard_input=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Input file list from stdin
	       no_stdin | no_inp_std | no_redirect | no_standard_input ) std_chk='No' ;; # # Do not check stdin for input file list
	       no_stdin=?* | no_inp_std=?* | no_redirect=?* | no_standard_input=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Do not check stdin for input file list
	       stg_grd | stg | stagger | staggered_grid ) stg_grd='Yes' ;; # # Add staggered grid variables
	       stg_grd=?* | stg=?* | stagger=?* | staggered_grid ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Add staggered grid variables
	       no_stg_grd | no_stg | no_stagger | no_staggered_grid ) stg_grd='No' ;; # # Omit staggered grid variables
	       no_stg_grd=?* | no_stg=?* | no_stagger=?* | no_staggered_grid ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Omit staggered grid variables
	       drc_tmp=?* | tmp_drc=?* | dir_tmp=?* | tmp_dir=?* | tmp=?* ) tmp_usr="${LONG_OPTARG}" ;; # -T # Temporary directory
	       thr_nbr=?* | thr=?* | thread_number=?* | thread=?* | threads=?* ) thr_usr="${LONG_OPTARG}" ;; # -t # Thread number
	       unpack=?* | upk=?* | upk_inp=?* ) pdq_opt='-U' ;; # -U # Unpack input
	       unpack=?* | upk=?* | upk_inp=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # -U # Unpack input
	       ugrid_fl=?* | ugrid=?* | ugrid_file=?* ) ugrid_fl="${LONG_OPTARG}" ;; # # UGRID file
	       uio | unbuffered | share ) uio_flg='Yes' ;; # # Unbuffered I/O (NC_SHARE) for netCDF3 files
	       uio=?* | unbuffered=?* | share=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Unbuffered I/O (NC_SHARE) for netCDF3 files
	       unq_sfx=?* | unique_suffix=?* | suffix=?* ) unq_usr="${LONG_OPTARG}" ;; # -u # Unique suffix
	       var_rgr=?* | rgr_var=?* | var_cf=?* | cf_var=?* | cf_variable=?* ) var_rgr="${LONG_OPTARG}" ;; # -V # CF template variable 
	       var_lst=?* | variable_list=?* | var=?* | vars=?* | variable=?* | variables=?* ) var_lst="${LONG_OPTARG}" ;; # -v # Variables
	       version | vrs | config | configuration | cnf ) vrs_prn='Yes' ;; # # Print version information
	       version=?* | vrs=?* | config=?* | configuration=?* | cnf=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Print version information
	       vrb_lvl=?* | vrb=?* | verbosity=?* | print_verbosity=?* ) vrb_lvl="${LONG_OPTARG}" ;; # # Print verbosity
	       vrt_in=?* | vrt_grd_in=?* ) vrt_in="${LONG_OPTARG}" ;; # # Vertical grid file for input
	       vrt_nm=?* | plev_nm=?* | vrt_crd=?* | vertical_coordinate_name=?* ) vrt_nm="${LONG_OPTARG}" ;; # # Vertical coordinate name
	       vrt_ntp=?* | ntp_mth=?* | interpolation_type=?* | interpolation_method=?* ) vrt_ntp="${LONG_OPTARG}" ;; # # Vertical interpolation type (lin|log)
	       vrt_out=?* | vrt_fl=?* | vrt=?* | vrt_grd_out=?* ) vrt_out="${LONG_OPTARG}" ;; # # Vertical grid file for output
	       vrt_xtr=?* | xtr_mth=?* | extrapolation_type=?* | extrapolation_method=?* ) vrt_xtr="${LONG_OPTARG}" ;; # # Vertical extrapolation type (linear|mss_val|nrs_ngh|zero)
	       wgt_opt=?* | esmf_opt=?* | esmf_options=?* | tps_opt=?* | tempest_opt=?* | tempest_options=?* ) wgt_opt_usr="${LONG_OPTARG}" ;; # -W # Weight-generator options
	       wgt_cmd=?* | weight_command=?* | wgt_gnr=?* | weight_generator=?* ) wgt_usr="${LONG_OPTARG}" ;; # -w # Weight-generator command
	       xcl_var | xcl | exclude | exclude_variables ) xcl_flg='Yes' ;; # # Exclude rather than extract variable list
	       xcl_var=?* | xcl=?* | exclude=?* | exclude_variables=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Exclude rather than extract variable list
	       xtn_var=?* | extensive=?* | var_xtn=?* | extensive_variables=?* ) xtn_var="${LONG_OPTARG}" ;; # -x # Extensive variables
	       xtr_nsp=?* | xtr_pnt_src_nbr=?* | extrap_num_src_pts=?* ) xtr_nsp_usr="${LONG_OPTARG}" ;; # # Extrapolation number of source points (for ESMF & NCO only)
	       xtr_xpn=?* | xtr_dst_xpn=?* | extrap_dist_exponent=?* ) xtr_xpn_usr="${LONG_OPTARG}" ;; # # Extrapolation inverse-distance exponent (for ESMF & NCO only)
               '' ) break ;; # "--" terminates argument processing
               * ) printf "\nERROR: Unrecognized option ${fnt_bld}--${OPTARG}${fnt_nrm}\n" >&2; fnc_usg_prn ;;
	   esac ;; # !OPTARG
	\?) # Unrecognized option
	    printf "\nERROR: Option ${fnt_bld}-${OPTARG}${fnt_nrm} not recognized\n" >&2
	    fnc_usg_prn ;;
    esac # !OPT
done # !getopts
shift $((OPTIND-1)) # Advance one argument
psn_nbr=$#
if [ ${psn_nbr} -ge 1 ]; then
    # 20200430 Input files as positional command-line arguments mean we need not check standard-input
    inp_psn='Yes'
    std_chk='No'
fi # !psn_nbr
if [ -n "${in_fl}" ]; then
    # 20200430 Input file as single optional command-line argument means we need not check standard-input
    inp_aut='Yes'
    std_chk='No'
fi # !in_fl
if [ "${d2f_flg}" != 'Yes' ]; then
    d2f_opt=''
fi # !d2f_flg

# https://stackoverflow.com/questions/37056192/which-vs-command-v-in-bash
cmd_wgt_esmf=`command -v ${wgt_exe_esmf} --no_log 2> /dev/null`
cmd_cnv_mbt=`command -v ${cnv_exe_mbt} 2> /dev/null`
cmd_cnv_tps=`command -v ${cnv_exe_tps} 2> /dev/null`
cmd_dpt_mpas=`command -v ${dpt_exe_mpas} --no_log 2> /dev/null`
cmd_prt_mbt=`command -v ${prt_exe_mbt} 2> /dev/null`
cmd_wgt_cdo=`command -v ${wgt_exe_cdo} 2> /dev/null`
cmd_wgt_mbt=`command -v ${wgt_exe_mbt} 2> /dev/null`
cmd_wgt_nco=`command -v ${wgt_exe_nco} 2> /dev/null`
cmd_wgt_tps=`command -v ${wgt_exe_tps} 2> /dev/null`
cmd_msh_tps=`command -v ${msh_exe_tps} 2> /dev/null`
if [ ${vrs_prn} = 'Yes' ]; then
    printf "${spt_nm}, the NCO regridder and grid, map, and weight-generator, version ${nco_vrs} \"${nco_sng}\"\n"
    printf "Copyright (C) 2016--present Charlie Zender\n"
    printf "This program is part of NCO, the netCDF Operators\n"
    printf "NCO is free software and comes with a BIG FAT KISS and ABSOLUTELY NO WARRANTY\n"
    printf "You may redistribute and/or modify NCO under the terms of the\n"
    printf "3-Clause BSD License with exceptions described in the LICENSE file\n"
    printf "BSD: https://opensource.org/licenses/BSD-3-Clause\n"
    printf "LICENSE: https://github.com/nco/nco/tree/master/LICENSE\n"
    printf "Config: ${spt_nm} script located in directory ${drc_spt}\n"
    printf "Config: NCO binaries located in directory ${drc_nco}, linked to netCDF library version ${lbr_vrs}\n"
    if [ "${hrd_pth_fnd}" = 'Yes' ]; then
	printf "Config: Employ NCO machine-dependent hardcoded paths/modules for ${HOSTNAME}. (If desired, turn-off NCO hardcoded paths with \"export NCO_PATH_OVERRIDE=No\").\n"
    else
	printf "Config: No hardcoded machine-dependent path/module overrides. (If desired, turn-on NCO hardcoded paths at supported national labs with \"export NCO_PATH_OVERRIDE=Yes\").\n"
    fi # !hrd_pth_fnd
    printf "Config: Grid & weight-generation tool availability:\n"
    if [ -n "${cmd_wgt_cdo}" ]; then
	printf "Config: CDO weight-generation command ${wgt_exe_cdo} found as ${cmd_wgt_cdo}\n"
    else
	printf "Config: CDO weight-generation command ${wgt_exe_cdo} not found\n"
    fi # !err
    if [ -n "${cmd_wgt_esmf}" ]; then
	printf "Config: ESMF weight-generation command ${wgt_exe_esmf} found as ${cmd_wgt_esmf}\n"
    else
	printf "Config: ESMF weight-generation command ${wgt_exe_esmf} not found\n"
    fi # !err
    if [ -n "${cmd_wgt_mbt}" ]; then
	printf "Config: MOAB-Tempest mesh- and weight-generation command ${wgt_exe_mbt} found as ${cmd_wgt_mbt}\n"
    else
	printf "Config: MOAB-Tempest mesh- and weight-generation command ${wgt_exe_mbt} not found\n"
    fi # !err
    if [ -n "${cmd_cnv_mbt}" ]; then
	printf "Config: MOAB-Tempest SCRIP/Exodus conversion to H5M command ${cnv_exe_mbt} found as ${cmd_cnv_mbt}\n"
    else
	printf "Config: MOAB-Tempest SCRIP/Exodus conversion to H5M command ${cnv_exe_mbt} not found\n"
    fi # !err
    if [ -n "${cmd_prt_mbt}" ]; then
	printf "Config: MOAB-Tempest H5M partition command ${prt_exe_mbt} found as ${cmd_prt_mbt}\n"
    else
	printf "Config: MOAB-Tempest H5M partition command ${prt_exe_mbt} not found\n"
    fi # !err
    if [ -n "${cmd_dpt_mpas}" ]; then
	printf "Config: MPAS depth coordinate addition command ${dpt_exe_mpas} found as ${cmd_dpt_mpas}\n"
    else
	printf "Config: MPAS depth coordinate addition command ${dpt_exe_mpas} not found\n"
    fi # !err
    if [ -n "${cmd_wgt_nco}" ]; then
	printf "Config: NCO mesh- and weight-generation command ${wgt_exe_nco} found as ${cmd_wgt_nco}\n"
    else
	printf "Config: NCO mesh- and weight-generation command ${wgt_exe_nco} not found\n"
    fi # !err
    if [ -n "${cmd_wgt_tps}" ]; then
	printf "Config: TempestRemap weight-generation command ${wgt_exe_tps} found as ${cmd_wgt_tps}\n"
    else
	printf "Config: TempestRemap weight-generation command ${wgt_exe_tps} not found\n"
    fi # !err
    if [ -n "${cmd_msh_tps}" ]; then
	printf "Config: TempestRemap mesh-generation command ${msh_exe_tps} found as ${cmd_msh_tps}\n"
    else
	printf "Config: TempestRemap weight-generation command ${msh_exe_tps} not found\n"
    fi # !err
    if [ -n "${cmd_cnv_tps}" ]; then
	printf "Config: TempestRemap Mesh or SCRIP to Exodus conversion command ${cnv_exe_tps} found as ${cmd_cnv_tps}\n"
    else
	printf "Config: TempestRemap Mesh or SCRIP to Exodus conversion command ${cnv_exe_tps} not found\n"
    fi # !err
    exit 0
fi # !vrs_prn

# Detect input on pipe to stdin:
# http://stackoverflow.com/questions/2456750/detect-presence-of-stdin-contents-in-shell-script
# http://unix.stackexchange.com/questions/33049/check-if-pipe-is-empty-and-run-a-command-on-the-data-if-it-isnt
# 20170119 "if [ ! -t 0 ]" tests whether unit 0 (stdin) is connected to terminal, not whether pipe has data
# Non-interactive batch mode (e.g., qsub, sbatch) disconnects stdin from terminal and triggers false-positives with ! -t 0
# 20170123 "if [ -p foo ]" tests whether foo exists and is a pipe or named pipe
# Non-interactive batch mode (i.e., sbatch) behaves as desired for -p /dev/stdin on SLURM
# Non-interactive batch mode (e.g., qsub) always returns true for -p /dev/stdin on PBS, leads to FALSE POSITIVES!
# This is because PBS uses stdin to set the job name
# Hence -p /dev/stdin test works everywhere tested except PBS non-interactive batch environment
# Check stdin if user has not explicitly disallowed it with --no_stdin
if [ "${std_chk}" = 'Yes' ]; then
    if [ -n "${PBS_ENVIRONMENT}" ]; then
	if [ "${PBS_ENVIRONMENT}" = 'PBS_BATCH' ]; then
	    # PBS batch detection suggested by OLCF ticket CCS #338970 on 20170127
	    bch_pbs='Yes'
	fi # !PBS_ENVIRONMENT
    fi # !PBS
    if [ -n "${SLURM_JOBID}" ] && [ -z "${SLURM_PTY_PORT}" ]; then
	# SLURM batch detection suggested by NERSC ticket INC0096873 on 20170127
	bch_slr='Yes'
    fi # !SLURM
    if [ ${bch_pbs} = 'Yes' ] || [ ${bch_slr} = 'Yes' ]; then
	# Batch environment
	if [ ${bch_pbs} = 'Yes' ]; then
	    if [ ! -p /dev/stdin ]; then
		# PBS batch jobs cause -p to return true except for stdin redirection 
		# When -p returns true we do not know whether stdin pipe contains any input
		# User must explicitly indicate use of stdin pipes with --stdin option
		# Redirection in PBS batch jobs unambiguously causes -p to return false
		inp_std='Yes'
	    fi # !stdin
	fi # !bch_slr
	if [ ${bch_slr} = 'Yes' ]; then
	    if [ -p /dev/stdin ]; then
		# SLURM batch jobs cause -p to return true for stdin pipes
		# When -p returns false we do not know whether output was redirectd
		# User must explicitly indicate use of redirection with --stdin option
		# Stdin pipes in SLURM batch jobs unambiguously cause -p to return true
		inp_std='Yes'
	    fi # !stdin
	fi # !bch_slr
    else # !bch
	# Interactive environment
	if [ -p /dev/stdin ] || [ ! -t 0 ]; then
	    # Interactive environments unambiguously cause -p to return true for stdin pipes
	    # Interactive environments unambiguously cause -t 0 to return false for stdin redirection
	    inp_std='Yes'
	fi # !stdin
    fi # !bch
    if [ ${inp_std} = 'Yes' ] && [ ${inp_psn} = 'Yes' ]; then
	echo "${spt_nm}: ERROR expecting input from both stdin and positional command-line arguments\n"
	exit 1
    fi # !inp_std
fi # !std_chk

# Derived variables
if [ -n "${drc_usr}" ]; then
    chr_fst=${drc_usr:0:1}
    if [ "${chr_fst}" = '-' ]; then
	printf "${spt_nm}: WARNING first character of user-specified output directory drc_out is \"${chr_fst}\", which looks like an option itself. Be sure the ${spt_nm} '-O' option is followed by an argument that specifies the output directory for regridded files. The '-O' option requires a pathname argument, and should not be confused with the '-O' flag (which takes no argument) used in the rest of NCO to force overwriting files (${spt_nm} automatically overwrites existing output files).\n"
    fi # !chr_fst
    drc_out="${drc_usr%/}"
else
    if [ -n "${out_fl}" ]; then
	drc_out="$(dirname ${out_fl})"
    fi # !out_fl
fi # !drc_usr

if [ -n "${tmp_usr}" ]; then
    # Fancy %/ syntax removes trailing slash (e.g., from $TMPDIR)
    drc_tmp=${tmp_usr%/}
fi # !tmp_usr
dmm_fl="${drc_tmp}/ncremap_tmp_dmm.nc" # [sng] Dummy input file
grd_dst_dfl="${drc_tmp}/ncremap_tmp_grd_dst.nc" # [sng] Grid-file (destination) default
grd_dst_h5m_dfl="${drc_tmp}/ncremap_tmp_grd_dst_h5m.nc" # [sng] H5M Grid-file (destination) default
grd_dst_prt_dfl="${drc_tmp}/ncremap_tmp_grd_dst_h5m_prt.nc" # [sng] Partitioned H5M mesh (destination) default
grd_src_dfl="${drc_tmp}/ncremap_tmp_grd_src.nc" # [sng] Grid-file (source) default
grd_src_h5m_dfl="${drc_tmp}/ncremap_tmp_grd_src_h5m.nc" # [sng] H5M Grid-file (source) default
grd_src_prt_dfl="${drc_tmp}/ncremap_tmp_grd_src_h5m_prt.nc" # [sng] Partitioned H5M mesh (source) default
hnt_dst_fl="${drc_tmp}/ncremap_tmp_hnt_dst.txt" # [sng] Hint (for ERWG) destination
hnt_src_fl="${drc_tmp}/ncremap_tmp_hnt_src.txt" # [sng] Hint (for ERWG) source
ncwa_fl="${drc_tmp}/ncremap_tmp_ncwa.nc" # [sng] ncwa workflow (HIRDLS, MLS) default
nnt_fl="${drc_tmp}/ncremap_tmp_nnt.nc" # [sng] Annotated global datafile (RRG) default
rgn_fl="${drc_tmp}/ncremap_tmp_rgn.nc" # [sng] Regional file with coordinates (RRG) default
tmp_out_fl="${drc_tmp}/ncremap_tmp_out.nc" # [sng] Temporary output file
znl_fl="${drc_tmp}/ncremap_tmp_znl.nc" # [sng] Zonal workflow (HIRDLS, MLS) default

if [ -n "${unq_usr}" ]; then
    if [ "${unq_usr}" = 'noclean' ]; then
	cln_flg='No'
    else
	if [ "${unq_usr}" = 'none' ] || [ "${unq_usr}" = 'nil' ]; then
	    unq_sfx=""
	else # !unq_usr
	    unq_sfx="${unq_usr}"
	fi # !unq_usr
    fi # !unq_usr
fi # !unq_usr
dmm_fl=${dmm_fl}${unq_sfx}
grd_dst_h5m_tmp=${grd_dst_h5m_dfl}${unq_sfx}
grd_src_h5m_tmp=${grd_src_h5m_dfl}${unq_sfx}
grd_dst_prt_tmp=${grd_dst_prt_dfl}${unq_sfx}
grd_src_prt_tmp=${grd_src_prt_dfl}${unq_sfx}
grd_dst_dfl=${grd_dst_dfl}${unq_sfx}
grd_src_dfl=${grd_src_dfl}${unq_sfx}
hnt_dst_fl=${hnt_dst_fl}${unq_sfx}
hnt_src_fl=${hnt_src_fl}${unq_sfx}
ncwa_fl=${ncwa_fl}${unq_sfx}
nnt_fl=${nnt_fl}${unq_sfx}
rgn_fl=${rgn_fl}${unq_sfx}
tmp_out_fl=${tmp_out_fl}${unq_sfx}
znl_fl=${znl_fl}${unq_sfx}

# Algorithm options are bilinear|conserve|conserve2nd|nearestdtos|neareststod|patch|traave|trbilin|trfv2|trintbilin|se2fv_flx|se2fv_stt|se2fv_alt|se2se|fv2se_flx|fv2se_stt|fv2se_alt|fv2fv_flx|fv2fv_stt|ncoaave|nco_con|ncoidw
if [ ${alg_typ} = 'cdo_con' ] || [ ${alg_typ} = 'cdo_cns' ] || [ ${alg_typ} = 'cdo_conserve' ] || [ ${alg_typ} = 'cdo' ]; then 
    alg_opt='gencon'
    wgt_typ='cdo'
elif [ ${alg_typ} = 'cdo_bil' ] || [ ${alg_typ} = 'cdo_bilin' ] || [ ${alg_typ} = 'cdo_bilinear' ]; then 
    alg_opt='genbil'
    wgt_typ='cdo'
elif [ ${alg_typ} = 'bilinear' ] || [ ${alg_typ} = 'esmfbilin' ] || [ ${alg_typ} = 'bilin' ] || [ ${alg_typ} = 'blin' ] || [ ${alg_typ} = 'bln' ]; then 
    alg_opt='bilinear'
    wgt_typ='esmf'
# 20211118 Default to nearestidavg extrapolation with bilinear algorithm (as E3SM does), unless user explicitly specifies an extrapolation type
    if [ -z "${esmf_typ}" ]; then
	esmf_typ='nearestidavg'
    fi # !esmf_typ
elif [ ${alg_typ} = 'conserve' ] || [ ${alg_typ} = 'esmfaave' ] || [ ${alg_typ} = 'conservative' ] || [ ${alg_typ} = 'cns' ] || [ ${alg_typ} = 'c1' ] || [ ${alg_typ} = 'aave' ]; then 
    alg_opt='conserve'
    wgt_typ='esmf'
elif [ ${alg_typ} = 'conserve2nd' ] || [ ${alg_typ} = 'conservative2nd' ] || [ ${alg_typ} = 'c2' ] || [ ${alg_typ} = 'c2nd' ]; then 
    alg_opt='conserve2nd'
    wgt_typ='esmf'
elif [ ${alg_typ} = 'nearestdtos' ] || [ ${alg_typ} = 'esmfndtos' ] || [ ${alg_typ} = 'ndtos' ] || [ ${alg_typ} = 'dtos' ] || [ ${alg_typ} = 'nds' ]; then 
    alg_opt='nearestdtos'
    wgt_typ='esmf'
elif [ ${alg_typ} = 'neareststod' ] || [ ${alg_typ} = 'esmfnstod' ] || [ ${alg_typ} = 'nstod' ] || [ ${alg_typ} = 'stod' ] || [ ${alg_typ} = 'nsd' ]; then 
    alg_opt='neareststod'
    wgt_typ='esmf'
elif [ ${alg_typ} = 'patch' ] || [ ${alg_typ} = 'patc' ] || [ ${alg_typ} = 'pch' ]; then 
    alg_opt='patch'
    wgt_typ='esmf'
elif [ ${alg_typ} = 'se2fv_flx' ] || [ ${alg_typ} = 'mono_se2fv' ] || [ ${alg_typ} = 'conservative_monotone_se2fv' ]; then # alg_sng='mono'
    # 20171108 'tempest' invokes TempestRemap with no automatic options, suitable for RLL re-mapping?
    # 20171108 TempestRemap boutique options based on particular remapping type
    # 20200221 Add --correct_areas to many TR maps as per Transition to TR page
    # 20220928 Remove --correct_areas since TR 2.1.12 made this default and eliminated option
    # 20220928 Replace --mono3 by --method mono3 since TR 2.1.14, 2.1.15 changed option name
    # 20231130 Correct wgt_opt_mbt for alg_typ=tempest to use order = ${se_np_nbr} == 4 by default (since TR uses order=4)
    # 20240110 Replace --method mono* by --mono* since MWF mode revealed some failures with --method mono*
    # 20250604 Remove alg_typ=tempest because it is ambiguous and confused me, Walter H., and likely other users
    # https://acme-climate.atlassian.net/wiki/spaces/Docs/pages/178848194/Transition+to+TempestRemap+for+Atmosphere+grids
    # alg_sng in comments is for E3SM naming convention map_src_to_dst_${alg_sng}.${dt_sng}.nc
    cnv_opt_src="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    cnv_opt_dst="-B"
    wgt_opt_mbt="--method cgll --order ${se_np_nbr} --global_id GLOBAL_DOFS --method fv --monotonicity 1 --global_id GLOBAL_ID"
    wgt_opt_tps="--in_type cgll --in_np ${se_np_nbr} --out_type fv --mono"
    alg_opt='se2fv_flx'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'se2fv_stt' ] || [ ${alg_typ} = 'highorder_se2fv' ] || [ ${alg_typ} = 'accurate_conservative_nonmonotone_se2fv' ]; then # alg_sng='highorder'
    cnv_opt_src="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    cnv_opt_dst="-B"
    wgt_opt_mbt="--method cgll --order ${se_np_nbr} --method fv"
    wgt_opt_tps="--in_type cgll --in_np ${se_np_nbr} --out_type fv"
    alg_opt='se2fv_stt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'se2fv_alt' ] || [ ${alg_typ} = 'intbilin_se2fv' ] || [ ${alg_typ} = 'accurate_monotone_nonconservative_se2fv' ]; then # alg_sng='intbilin'
    cnv_opt_src="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    cnv_opt_dst="-B"
    wgt_opt_mbt="--method cgll --order ${se_np_nbr} --method fv --monotonicity 3 --noconserve"
    wgt_opt_tps="--in_type cgll --in_np ${se_np_nbr} --out_type fv --mono3 --noconserve"
    alg_opt='se2fv_alt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'se2se' ] || [ ${alg_typ} = 'cs2cs' ] || [ ${alg_typ} = 'conservative_monotone_se2se' ]; then # alg_sng='se2se'
    cnv_opt_src="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    cnv_opt_dst="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    # 20190227: Add mono for se2se per recommendation of Mark Taylor
    wgt_opt_mbt="--method cgll --order ${se_np_nbr} --method cgll --order ${se_np_nbr} --monotonicity 1"
    wgt_opt_tps="--in_type cgll --in_np ${se_np_nbr} --out_type cgll --out_np ${se_np_nbr} --mono"
    alg_opt='se2se'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2se_flx' ] || [ ${alg_typ} = 'monotr_fv2se' ] || [ ${alg_typ} = 'conservative_monotone_fv2se' ]; then # alg_sng='monotr'
    # NB: Generate mono map for opposite direction regridding (i.e., reverse switches and grids), then transpose
    cnv_opt_src="-B"
    cnv_opt_dst="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    wgt_opt_mbt="--method cgll --order ${se_np_nbr} --method fv --monotonicity 1"
    wgt_opt_tps="--in_type cgll --in_np ${se_np_nbr} --out_type fv --mono"
    alg_opt='fv2se_flx'
    wgt_typ='tempest'
    trn_map='Yes'
elif [ ${alg_typ} = 'fv2se_stt' ] || [ ${alg_typ} = 'highorder_fv2se' ] || [ ${alg_typ} = 'accurate_conservative_nonmonotone_fv2se' ]; then # alg_sng='highorder'
    cnv_opt_src="-B"
    cnv_opt_dst="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    # 20190716: Remove "--volumetric" from fv2se_stt per Mark Taylor and Paul Ullrich
    wgt_opt_mbt="--method fv --order 2 --method cgll --order ${se_np_nbr}"
    wgt_opt_tps="--in_type fv --in_np 2 --out_type cgll --out_np ${se_np_nbr}"
    alg_opt='fv2se_stt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2se_alt' ] || [ ${alg_typ} = 'mono_fv2se' ] || [ ${alg_typ} = 'conservative_monotone_fv2se_alt' ]; then # alg_sng='mono'
    cnv_opt_src="-B"
    cnv_opt_dst="-B -i GLOBAL_DOFS -r ${se_np_nbr}"
    # 20200525: Remove "--volumetric" from fv2se_mono per Mark Taylor modifying Confluence instructions
    wgt_opt_mbt="--method fv --order 1 --method cgll --order ${se_np_nbr} --monotonicity 1"
    wgt_opt_tps="--in_type fv --in_np 1 --out_type cgll --out_np ${se_np_nbr} --mono"
    alg_opt='fv2se_alt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2fv' ] || [ ${alg_typ} = 'rll2rll' ]; then # alg_sng='highorder'
    cnv_opt_src="-B"
    cnv_opt_dst="-B"
    # 20190227: Add --mono3 --noconserve for fv2fv per (misinterpreted) recommendation of Mark Taylor
    # 20200115: Replace --mono3 --noconserve with --in_np 2 per recommendation of Mark Taylor and Paul Ullrich
    wgt_opt_mbt='--method fv --order 2 --method fv'
    wgt_opt_tps='--in_type fv --in_np 2 --out_type fv'
    alg_opt='fv2fv'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2fv_flx' ] || [ ${alg_typ} = 'traave' ] || [ ${alg_typ} = 'fv2fv_mono' ] || [ ${alg_typ} = 'conservative_monotone_fv2fv' ]; then # alg_sng='traave'
    cnv_opt_src="-B"
    cnv_opt_dst="-B"
    # 20191115: Add per recommendation of Paul Ullrich
    # 20200221: Add --out_np 1 per (new?) settings in on Transition to TR page
    # Classic cell-integrated piecewise constant map similar to aave and nco_con
    wgt_opt_mbt='--method fv --order 1 --method fv --order 1'
    wgt_opt_tps='--in_type fv --in_np 1 --out_type fv --out_np 1'
    alg_opt='fv2fv_flx'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'trfv2' ] || [ ${alg_typ} = 'trfvnp2' ]; then # alg_sng='trfv2'
    cnv_opt_src="-B"
    cnv_opt_dst="-B"
    # 20231129: E3SMv3 recommended for fluxes when source grid resolution uniformly is _not_ >> target grid resolution (e.g., ne30pg2->r05), i.e., coarse->fine
    # 20231129: E3SMv3 recommended for states when source grid resolution uniformly << target grid resolution (e.g., ne30pg2->r05), i.e., coarse->fine
    # 2nd order FV reconstruction, cell integrated on target grid (conservative, though not monotone unless used with FV2+CAAS method)
    # https://acme-climate.atlassian.net/wiki/spaces/DOC/pages/178848194/Recommended+Mapping+Procedures+for+E3SM+Atmosphere+Grids
    # https://acme-climate.atlassian.net/wiki/spaces/COM/pages/3771301899/Coupler+High-order+property-preserving+maps
    wgt_opt_mbt='--method fv --order 2 --method fv --order 1 --fvmethod normalize'
    wgt_opt_tps='--in_type fv --in_np 2 --out_type fv --out_np 1 --method normalize'
    alg_opt='trfv2'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2fv_stt' ] || [ ${alg_typ} = 'fv2fv_highorder' ] || [ ${alg_typ} = 'accurate_conservative_nonmonotone_fv2fv' ]; then # alg_sng='highorder'
    cnv_opt_src="-B"
    cnv_opt_dst="-B"
    # 20191115: Add per recommendation of Paul Ullrich
    # --in_np 2 means all nearest neighbor cells will be used for higher order reconstruction of source data, which is then integrated over target cell. Unlike SE case, no mass matrix is used for FV target grids, and thus --out_np is ignored (and will always be 1 internally).
    wgt_opt_mbt='--method fv --order 2 --method fv'
    wgt_opt_tps='--in_type fv --in_np 2 --out_type fv'
    alg_opt='fv2fv_stt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'trbilin' ]; then # alg_sng='trbilin'
    # 20231001: Added with options per https://acme-climate.atlassian.net/wiki/spaces/DOC/pages/1217757434/Mapping+file+algorithms+and+naming+convention
    cnv_opt_src="-B"
    cnv_opt_dst="-B"
    wgt_opt_mbt='--method fv --method fv --order 1 --order 1 --fvmethod bilin'
    wgt_opt_tps='--in_type fv --out_type fv --method bilin'
    alg_opt='trbilin'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'trintbilin' ]; then # alg_sng='trintbilin'
    # 20231001: Added with options per https://acme-climate.atlassian.net/wiki/spaces/DOC/pages/1217757434/Mapping+file+algorithms+and+naming+convention
    cnv_opt_src="-B"
    cnv_opt_dst="-B"
    wgt_opt_mbt='--method fv --method fv --order 1 --order 1 --fvmethod intbilin'
    wgt_opt_tps='--in_type fv --out_type fv --method intbilin'
    alg_opt='trintbilin'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'nco_con' ] || [ ${alg_typ} = 'ncoaave' ] || [ ${alg_typ} = 'nco_cns' ] || [ ${alg_typ} = 'nco_conserve' ] || [ ${alg_typ} = 'nco' ]; then # alg_sng='ncoaave'
    alg_opt='ncoaave'
    wgt_typ='nco'
elif [ ${alg_typ} = 'nco_idw' ] || [ ${alg_typ} = 'ncoidw' ] || [ ${alg_typ} = 'nco_dwe' ] || [ ${alg_typ} = 'dwe' ] || [ ${alg_typ} = 'idw' ] || [ ${alg_typ} = 'nco_distance_weighted' ] || [ ${alg_typ} = 'nco_nearest_neighbor' ]; then
    alg_opt='ncoidw'
    wgt_typ='nco'
else 
    echo "${spt_nm}: ERROR ${alg_typ} is not a valid weight-generation algorithm"
    echo "${spt_nm}: HINT Valid CDO weight-generation algorithms and synonyms are cdo_bil,cdo_bilin,cdo_bilinear | cdo_con,cdo_cns,cdo_conserve"
    echo "${spt_nm}: HINT Valid ESMF weight-generation algorithms and synonyms are esmfbilin,bilinear,bilin,bln | esmfaave,conserve,cns,c1,aave | conserve2nd,c2,c2nd | nearestdtos,nds,dtos | neareststod,nsd,stod | patch,pch"
    echo "${spt_nm}: HINT Valid NCO weight-generation algorithms and synonyms are ncoaave,nco_con,nco_cns,nco_conserve,nco | nco_idw,nco_dwe"
    echo "${spt_nm}: HINT Valid TempestRemap (and MOAB-TempestRemap) weight-generation options and synonyms are traave,fv2fv_flx,fv2fv_mono | trbilin | trfv2 | trintbilin | se2fv_flx,mono_se2fv | se2fv_stt,highorder_se2fv | se2fv_alt,intbilin | se2se,cs2cs | fv2se_flx,monotr_fv2se | fv2se_stt,highorder_fv2se | fv2se_alt,mono_fv2se | fv2fv,rll2rll"
    exit 1
fi # !alg_typ

if [ -n "${mpi_nbr_usr}" ]; then
    mpi_nbr=${mpi_nbr_usr}
fi # !mpi_nbr_usr
# Specifying a TR algorithm and explicitly setting mpi_nbr implies MOAB
if [ ${wgt_typ} = 'tempest' ] && [ -n "${mpi_nbr_usr}" ]; then
    wgt_typ='mbtempest'
fi # !wgt_typ
# If user explicitly sets mpi_nbr then we need a prefix
if [ -n "${mpi_nbr_usr}" ]; then
    # ...then set prefix for invoking MPI-enabled weight generators 
    case "${HOSTNAME}" in 
	acme1* ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	andes* ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	blues* | blogin* | b[0123456789][0123456789][0123456789] ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	chrysalis* | chrlogin* | chr-[0123456789][0123456789][0123456789][0123456789] ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	*cheyenne* ) mpi_pfx="mpirun -n ${mpi_nbr}" ; ;; 
	compy* | n[0123456789][0123456789][0123456789][0123456789] ) mpi_pfx="srun --mpi=pmi2 -n ${mpi_nbr}" ; ;; 
	constance* | node* ) mpi_pfx="mpirun -n ${mpi_nbr}" ; ;; 
	frontier* ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	login[0123456789][0123456789] ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	perlmutter* | nid[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789] ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; 
	# 20250122: Shift default node manager from mpirun to srun
	#	* ) mpi_pfx="mpirun -n ${mpi_nbr}" ; ;; # Default
	* ) mpi_pfx="srun -n ${mpi_nbr}" ; ;; # Default
    esac # !HOSTNAME
fi # !mpi_nbr
if [ -n "${mpi_pfx_usr}" ]; then 
    mpi_pfx="${mpi_pfx_usr}"
fi # !mpi_pfx_usr
# If MPI will be used, adjust partition number be a multiple of mpi_nbr
if [ -n "${mpi_pfx}" ]; then 
    if [ ${prt_nbr} -lt ${mpi_nbr} ]; then
	[[ ${dbg_lvl} -ge 1 ]] && echo "${spt_nm}: INFO Increasing partition number from ${prt_nbr} to ${mpi_nbr}"
	prt_nbr=${mpi_nbr}
    fi # !prt_nbr
    let prt_nbr_rmd=${prt_nbr}%${mpi_nbr}
    if [ ${prt_nbr_rmd} -ne 0 ]; then
	echo "${spt_nm}: ERROR Partition number prt_nbr=${prt_nbr} must be a multiple of the number of MPI tasks, mpi_nbr=${mpi_nbr}"
	echo "${spt_nm}: HINT Set partition number with --prt_nbr=${mpi_nbr} unless otherwise warranted"
	exit 1
    fi # !prt_nbr_rmd
fi # !mpi_pfx

# ERWG requires special handling for version-specific options
# 20210705: Avoid invoking ERWG to determine version unless actual algorithm requires ERWG
if [ ${wgt_typ} = 'esmf' ]; then
    # 20180830 Add --ignore_degenerate to default ERWG options for ESMF >= 7.1.0r
    # 20181114 Add --no_log so ERWG does not try to write logfile into current (possibly write-protected) directory 
    erwg_vrs_sng=`${mpi_pfx} ${wgt_exe_esmf} --no_log --version | grep ESMF_VERSION_STRING | cut -f 2 -d ':'`
    # Remove whitespace, answer should be something like "7.1.0r" or "6.3.0rp1"
    erwg_vrs_sng="${erwg_vrs_sng#"${erwg_vrs_sng%%[![:space:]]*}"}"
    # Extract first character
    erwg_vrs_mjr="${erwg_vrs_sng:0:1}"
    if [ -z "${erwg_vrs_mjr}" ]; then
	# Version can fail when ERWG fails, e.g., due to dynamic link issues
	printf "${spt_nm}: WARNING ${wgt_exe_esmf} (ERWG) found though does not run as expected. Possible dynamic linking issue due, e.g., to LD_LIBRARY_PATH configuration. Unable to determine ERWG version. ERWG may not be needed so continuing anyway...\n"
	erwg_vrs_sng='ERWG_VERSION_NOT_FOUND'
	erwg_vrs_mjr=7
    elif [ "${erwg_vrs_mjr}" -ge 7 ]; then
	wgt_opt_esmf="${wgt_opt_esmf} --ignore_degenerate"
    fi # !erwg_vrs_mjr
fi # !err

if [ -n "${fl_fmt}" ]; then
    if [ "${fl_fmt}" = '3' ] || [ "${fl_fmt}" = 'classic' ] || [ "${fl_fmt}" = 'netcdf3' ]; then
	nco_fl_fmt='--fl_fmt=classic'
	wgt_opt_tps="${wgt_opt_tps} --out_format Classic"
	msh_opt_tps="${msh_opt_tps} --out_format Classic"
	[[ ${wgt_typ} = 'mbtempest' ]] && map_nfo_sng="INFO: MOAB/mbtempest does not support writing map-file as requested type ${fmt_sng_nc3}, will write ${fmt_sng_nc4} instead"
    elif [ "${fl_fmt}" = '4' ] || [ "${fl_fmt}" = 'netcdf4' ] || [ "${fl_fmt}" = 'hdf5' ]; then
	nco_fl_fmt='--fl_fmt=netcdf4'
	wgt_opt_esmf="${wgt_opt_esmf} --netcdf4"
	wgt_opt_tps="${wgt_opt_tps} --out_format Netcdf4"
	msh_opt_tps="${msh_opt_tps} --out_format Netcdf4"
    elif [ "${fl_fmt}" = '5' ] || [ "${fl_fmt}" = '64bit_data' ] || [ "${fl_fmt}" = 'cdf5' ]; then
	nco_fl_fmt='--fl_fmt=64bit_data'
	wgt_opt_esmf="${wgt_opt_esmf} --netcdf4" # Change when ERWG supports CDF5
	wgt_opt_tps="${wgt_opt_tps} --out_format Netcdf4"
	msh_opt_tps="${msh_opt_tps} --out_format Netcdf4"
	[[ ${wgt_typ} != 'nco' ]] && map_nfo_sng="INFO: ${wgt_typ} does not support writing requested map-file as requested type ${fmt_sng_nc5}, will write ${fmt_sng_nc4} instead"
    elif [ "${fl_fmt}" = '6' ] || [ "${fl_fmt}" = '64bit_offset' ] || [ "${fl_fmt}" = '64' ]; then
	nco_fl_fmt='--fl_fmt=64bit_offset'
	wgt_opt_esmf="${wgt_opt_esmf} --64bit_offset"
	wgt_opt_tps="${wgt_opt_tps} --out_format Offset64Bits"
	msh_opt_tps="${msh_opt_tps} --out_format Offset64Bits"
	[[ ${wgt_typ} = 'mbtempest' ]] && map_nfo_sng="INFO: MOAB/mbtempest does not support writing requested map-file as requested type ${fmt_sng_nc6}, will write ${fmt_sng_nc4} instead"
    elif [ "${fl_fmt}" = '7' ] || [ "${fl_fmt}" = 'netcdf4_classic' ]; then
	nco_fl_fmt='--fl_fmt=netcdf4_classic'
	wgt_opt_esmf="${wgt_opt_esmf} --netcdf4" # Change when ERWG supports netCDF7
	wgt_opt_tps="${wgt_opt_tps} --out_format Netcdf4Classic"
	msh_opt_tps="${msh_opt_tps} --out_format Netcdf4Classic"
	[[ ${wgt_typ} != 'nco' ]] && map_nfo_sng="INFO: ${wgt_typ} does not support writing requested map-file as requested type ${fmt_sng_nc7}, will write ${fmt_sng_nc4} instead"
    else # !fl_fmt
	echo "${spt_nm}: ERROR User-supplied file-format specifier fl_fmt='${fl_fmt}' is invalid"
	echo "${spt_nm}: HINT Valid format-specifiers include '3', '4', '5', '6', and '7'"
	exit 1
    fi # !fl_fmt
    nco_opt="${nco_fl_fmt} ${nco_opt}"
fi # !fl_fmt

if [ -n "${nsx_alg}" ]; then
    if [ "${nsx_alg}" = 'adv' ] || [ "${nsx_alg}" = 'advfront' ] || [ "${nsx_alg}" = 'advancing_front' ]; then
	wgt_opt_mbt="--advfront ${wgt_opt_mbt}"
    elif [ "${nsx_alg}" = 'kd' ] || [ "${nsx_alg}" = 'kdtree' ]; then
    	wgt_opt_mbt="${wgt_opt_mbt}" # Kd-tree is default in mbtempest
    else
	echo "${spt_nm}: ERROR User-supplied intersection algorithm specifier nsx_alg='${nsx_alg}' is invalid"
	echo "${spt_nm}: HINT Valid intersection algorithm specifiers include 'advfront' and 'kdtree'"
	exit 1
    fi # !nsx_alg
fi # !nsx_alg
if [ -n "${xtr_nsp_usr}" ]; then
    xtr_nsp=${xtr_nsp_usr}
fi # !xtr_nsp_usr
if [ -n "${xtr_xpn_usr}" ]; then
    xtr_xpn=${xtr_xpn_usr}
fi # !xtr_xpn_usr

if [ -n "${esmf_typ}" ]; then
    # Configure ERWG options, if necessary
    if [ ${esmf_typ} = 'neareststod' ] || [ ${esmf_typ} = 'stod' ] || [ ${esmf_typ} = 'nsd' ]; then 
	esmf_opt='neareststod'
    elif [ ${esmf_typ} = 'nearestidavg' ] || [ ${esmf_typ} = 'idavg' ] || [ ${esmf_typ} = 'id' ]; then 
	esmf_opt='nearestidavg'
    elif [ ${esmf_typ} = 'none' ] || [ ${esmf_typ} = 'nil' ] || [ ${esmf_typ} = 'nowaydude' ]; then 
	esmf_opt='none'
    else 
	echo "${spt_nm}: ERROR ${esmf_typ} is not a valid extrapolation method"
	echo "${spt_nm}: HINT Valid ESMF extrapolation methods and synonyms are neareststod,stod,nsd | nearestidavg,idavg,id | none,nil"
	exit 1
    fi # !esmf_typ
    wgt_opt_esmf="${wgt_opt_esmf} --extrap_method ${esmf_opt} --extrap_num_src_pnts ${xtr_nsp} --extrap_dist_exponent ${xtr_xpn}"
fi # !esmf_typ

if [ ${wgt_typ} = 'cdo' ]; then
    wgt_cmd="${wgt_exe_cdo}"
    wgt_exe="${wgt_exe_cdo}"
    wgt_opt="${wgt_opt_cdo}"
elif [ ${wgt_typ} = 'esmf' ]; then
    wgt_cmd="${wgt_exe_esmf}"
    wgt_exe="${wgt_exe_esmf}"
    wgt_opt="${wgt_opt_esmf}"
elif [ ${wgt_typ} = 'nco' ]; then
    if [ "${alg_opt}" = 'nco_idw' ]; then
	wgt_opt_nco="${wgt_opt_nco} --rgr wgt_typ=${alg_opt} --rgr xtr_nsp=${xtr_nsp} --rgr xtr_xpn=${xtr_xpn}"
    fi # alg_opt
    wgt_cmd="${wgt_exe_nco}"
    wgt_exe="${wgt_exe_nco}"
    wgt_opt="${wgt_opt_nco}"
elif [ ${wgt_typ} = 'mbtempest' ]; then
    wgt_cmd="${wgt_exe_mbt}"
    wgt_exe="${wgt_exe_mbt}"
    wgt_opt="${wgt_opt_mbt}"
elif [ ${wgt_typ} = 'tempest' ]; then
    wgt_cmd="${wgt_exe_tps}"
    wgt_exe="${wgt_exe_tps}"
    wgt_opt="${wgt_opt_tps}"
else 
    echo "${spt_nm}: ERROR ${wgt_typ} is not a valid weight-type"
    exit 1
fi # !wgt_typ
# NB: Define after wgt_typ-block so user can override default options
if [ -n "${wgt_opt_usr}" ]; then 
    wgt_opt=${wgt_opt_usr}
fi # !wgt_opt_usr    
if [ -n "${mpi_pfx}" ]; then 
    if [ ${wgt_typ} = 'esmf' ] || [ ${wgt_typ} = 'mbtempest' ]; then
	wgt_cmd="${mpi_pfx} ${wgt_cmd}"
    fi # !wgt_typ
fi # !mpi_pfx
if [ -n "${wgt_usr}" ]; then 
    wgt_cmd=${wgt_usr}
fi # !wgt_usr    

if [ -z "${drc_in}" ]; then
    drc_in="${drc_pwd}"
else # !drc_in
    if [ ! -d "${drc_in}" ]; then
	echo "${spt_nm}: ERROR specified input directory \"${drc_in}\" does not exist"
	exit 1
    fi # !drc_in
    drc_in_usr_flg='Yes'
fi # !drc_in
if [ -n "${job_usr}" ]; then 
    job_nbr="${job_usr}"
fi # !job_usr
if [ -n "${mss_val_usr}" ]; then 
    mss_val=${mss_val_usr}
    att_flg='Yes'
fi # !mss_val_usr    
if [ ${dbg_lvl} -ge 2 ]; then
    nco_opt="--dbg_lvl=${dbg_lvl} ${nco_opt}"
fi # !dbg_lvl
if [ -n "${cmp_sng}" ]; then
    # 20230623: Insert backslashes to protect pipe characters from shell
    nco_opt="${nco_opt} --cmp=${cmp_sng//\|/\\|}"
fi # !cmp_sng
if [ -n "${col_dmn}" ]; then
    rgr_opt="${rgr_opt} --rgr col_nm=${col_dmn}"
fi # !col_dmn
if [ -n "${dfl_lvl}" ]; then
    nco_opt="${nco_opt} --dfl_lvl=${dfl_lvl}"
fi # !dfl_lvl
if [ -n "${qnt_prc}" ]; then
    nco_opt="${nco_opt} --qnt default=${qnt_prc}"
fi # !qnt_prc
if [ "${dvn_flg}" = 'Yes' ]; then
# 20210926 Omit 2>&1 since better for user to see error messages
# 20210926 Add 2>&1 to quiet unruly non-error output from mbconvert
    devnull=' > /dev/null'
else
    devnull=''
fi # !dfl_lvl
if [ -n "${hdr_pad}" ]; then 
    nco_opt="${nco_opt} --hdr_pad=${hdr_pad}"
fi # !hdr_pad
if [ -n "${uio_flg}" ]; then
    nco_opt="${nco_opt} --unbuffered_io"
fi # !uio_flg
if [ -n "${gaa_sng}" ]; then 
    nco_opt="${nco_opt} ${gaa_sng}"
fi # !gaa_sng
if [ -n "${gaa_sng}" ]; then 
    nco_opt="${nco_opt} ${gad_sng}"
fi # !gad_sng
if [ "${no_cll_msr}" = 'Yes' ]; then 
    nco_opt="${nco_opt} --no_cll_msr"
fi # !no_cll_msr
if [ "${no_frm_trm}" = 'Yes' ]; then 
    nco_opt="${nco_opt} --no_frm_trm"
fi # !no_frm_trm
if [ "${msk_apl}" = 'Yes' ]; then 
    rgr_opt="${rgr_opt} --rgr mask_apply"
fi # !msk_apl
if [ -n "${prs_stt_usr}" ]; then 
    if [ "${prs_stt_usr}" = 'mean' ] || [ "${prs_stt_usr}" = 'local' ] || [ "${prs_stt_usr}" = 'local_mean' ] || [ "${prs_stt_usr}" = 'gridcell' ] || [ "${prs_stt_usr}" = 'gridcell_mean' ] || [ "${prs_stt_usr}" = 'natural_values' ]; then
	prs_stt='mean'
    elif [ "${prs_stt_usr}" = 'integral' ] || [ "${prs_stt_usr}" = 'global' ] || [ "${prs_stt_usr}" = 'global_integral' ]; then
	prs_stt='integral'
    else
	echo "${spt_nm}: ERROR \"${prs_stt_usr}\" is an invalid value for preserved_statistic"
	echo "${spt_nm}: HINT The valid values for preserved_statistic are \"mean\" (or synonyms \"local\", \"local_mean\") and \"integral\" (or synonyms \"global\", \"global_integral\")"
	exit 1
    fi # !prs_stt_usr
    if [ "${prs_stt}" = 'mean' ] && [ -z "${rnr_thr}" ]; then 
	rnr_thr=0.0
    fi # !prs_stt
    if [ "${prs_stt}" = 'integral' ] && [ -n "${rnr_thr}" ]; then 
	if [ "${rnr_thr}" != 'off' ] && [ "${rnr_thr}" != 'none' ]; then
	    echo "${spt_nm}: ERROR preserved_statistic = \"${prs_stt}\" conflicts with rnr_thr=${rnr_thr}"
	    echo "${spt_nm}: HINT Explicitly specifying \"integral\" for the preserved-statistic is the same as turning-off renormalization so do not specify any value for renormalization"
	    exit 1
	fi # !rnr_thr
    fi # !prs_stt
fi # !prs_stt_usr
if [ -n "${var_lst}" ]; then 
    if [ "${xcl_flg}" = 'Yes' ]; then
	nco_var_lst="-x -v ${var_lst}"
    else
	nco_var_lst="-v ${var_lst}"
    fi # !xcl_flg
    nco_var_lst_hrz=${nco_var_lst}
fi # !var_lst
if [ -n "${area_dgn}" ]; then 
    nco_dgn_area="--rgr diagnose_area"
fi # !area_dgn
if [ -n "${msk_dst}" ]; then 
    nco_msk_dst="--rgr msk_var=${msk_dst}"
fi # !msk_dst
if [ "${msk_out}" != 'No' ]; then 
    nco_msk_out="--rgr msk_nm=${msk_out}"
fi # !msk_out
if [ -n "${msk_src}" ]; then 
    nco_msk_src="--rgr msk_var=${msk_src}"
fi # !msk_src
if [ -n "${skl_fl}" ]; then 
    nco_skl_fl="--rgr skl=\"${skl_fl}\""
fi # !skl_fl
if [ -n "${ugrid_fl}" ]; then 
    nco_ugrid_fl="--rgr ugrid=\"${ugrid_fl}\""
fi # !ugrid_fl
if [ -n "${var_rgr}" ]; then 
    nco_var_rgr="--rgr_var=${var_rgr}"
fi # !var_rgr
if [ -n "${xtn_var}" ]; then 
    rgr_opt="${rgr_opt} --xtn=${xtn_var}"
fi # !xtn_var
if [ -n "${out_fl}" ]; then 
    out_usr_flg='Yes'
fi # !out_fl
if [ "${par_typ}" = ${par_bck} ] || [[ "${par_typ}" =~ [bB]ck ]] || [[ "${par_typ}" =~ [bB]ackground ]]; then 
    par_typ=${par_bck}
    par_opt=' &'
elif [ "${par_typ}" = ${par_mpi} ] || [[ "${par_typ}" =~ (mpi|MPI) ]]; then 
    par_typ=${par_mpi}
    par_opt=' &'
    mpi_flg='Yes'
elif [ "${par_typ}" = ${par_srl} ] || [ "${par_typ}" = 'srl' ] || [[ "${par_typ}" =~ [sS]erial ]] || [[ "${par_typ}" =~ [nN]il ]] || [[ "${par_typ}" =~ [nN]one ]]; then 
    par_typ=${par_srl}
else 
    echo "ERROR: Invalid -p par_typ option = ${par_typ}"
    echo "HINT: Valid par_typ arguments include '${par_bck}' (or 'bck'), '${par_mpi}' (or 'MPI'), and '${par_srl}' (or 'srl' or 'nil' or 'none'). For background parallelism, select '${par_bck}' which causes ${spt_nm} to spawn parallel processes as background tasks on a single node. For MPI parallelism, select '${par_mpi}' which causes ${spt_nm} to spawn parallel processes on across available cluster nodes. For no parallelism (aka serial mode), select '${par_srl}', which causes ${spt_nm} to spawn all processes serially on a single compute node."
    exit 1
fi # !par_typ
if [ -n "${prc_typ}" ]; then
    if [ "${prc_typ}" != 'airs' ] && [ "${prc_typ}" != 'cam' ] && [ "${prc_typ}" != 'clm' ] && [ "${prc_typ}" != 'cice' ] && [ "${prc_typ}" != 'cpl' ] && [ "${prc_typ}" != 'ctsm' ] && [ "${prc_typ}" != 'eam' ] && [ "${prc_typ}" != 'eamxx' ] && [ "${prc_typ}" != 'elm' ] && [ "${prc_typ}" != 'hirdls' ] && [ "${prc_typ}" != 'mali' ] && [ "${prc_typ}" != 'mls' ] && [ "${prc_typ}" != 'mod04' ] && [ "${prc_typ}" != 'mpas' ] && [ "${prc_typ}" != 'mpasa' ] && [ "${prc_typ}" != 'mpasatmosphere' ] && [ "${prc_typ}" != 'mpaso' ] && [ "${prc_typ}" != 'mpasocean' ] && [ "${prc_typ}" != 'mpascice' ] && [ "${prc_typ}" != 'mpasseaice' ] && [ "${prc_typ}" != 'mpassi' ] && [ "${prc_typ}" != 'mwf' ] && [ "${prc_typ}" != 'nil' ] && [ "${prc_typ}" != 'rrg' ] && [ "${prc_typ}" != 'sgs' ]; then 
	    echo "ERROR: Invalid -P prc_typ option = ${prc_typ}"
	    echo "HINT: Valid prc_typ arguments are 'airs', 'cam', 'clm', 'cice', 'cpl', 'ctsm', 'eam', 'eamxx', 'elm', 'hirdls', 'mali', 'mls', 'mod04', 'mpas', 'mpasa', 'mpasatmosphere', 'mpaso', 'mpasocean', 'mpascice', 'mpasseaice', 'mpassi', 'mwf', 'nil', 'rrg', and 'sgs'"
	    exit 1
    fi # !prc_typ
fi # !prc_typ
if [ "${prc_typ}" = 'airs' ]; then 
    if [ -z "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then 
	pdq_opt='-a StdPressureLev,GeoTrack,GeoXTrack'
    fi # !pdq_opt
fi # !airs
if [ "${prc_typ}" = 'hirdls' ]; then 
    if [ -z "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then 
	pdq_opt='-a Pressure,Latitude,lon'
    fi # !pdq_opt
fi # !hirdls
if [ "${prc_typ}" = 'mls' ]; then 
    if [ -z "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then 
	pdq_opt='-a CO_Pressure,CO_Latitude,lon'
    fi # !pdq_opt
fi # !mls
if [ "${prc_typ}" = 'mod04' ]; then 
    if [ -z "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then 
	pdq_opt='-U'
    fi # !pdq_opt
    hnt_dst='--dst_regional'
fi # !mod04
if [ "${prc_typ}" = 'mali' ] || [ "${prc_typ}" = 'mpas' ] || [ "${prc_typ}" = 'mpasa' ] || [ "${prc_typ}" = 'mpasatmosphere' ] || [ "${prc_typ}" = 'mpaso' ] || [ "${prc_typ}" = 'mpasocean' ] || [ "${prc_typ}" = 'mpascice' ] || [ "${prc_typ}" = 'mpasseaice' ] || [ "${prc_typ}" = 'mpassi' ]; then 
    prc_mpas='Yes'
fi # !mpas, !mpasa, !mpascice, !mpaso, !mpasocean, !mpasseaice, !mpassi
if [ "${prc_mpas}" = 'Yes' ]; then 

    if [ "${prc_typ}" = 'mpasatmosphere' ]; then
	prc_typ='mpasa'
    fi # !mpasatmosphere
	
    # Add/alter missing metadata to MPAS files unless script was invoked by ncclimo (or with -C == --clm_flg)
    # NB: MPAS Analysis sets clm_flg=Yes to prevent ncremap from doing unnecessary _FillValue work
    # MPAS Analysis correctly deals with NaNs, masks, unset MPAS _FillValues, etc
    if [ "${clm_flg}" = 'No' ] && [ "${prc_typ}" != 'mpasa' ]; then
	att_flg='Yes'
    fi # !clm_flg

    if [ "${prc_typ}" = 'mali' ]; then
	mss_val='-1.0e36'
    fi # !prc_typ

    # MPAS components have historically not written _FillValue into fields
    # Instead MPAS writes zero to most (all?) fields in "non-computed" regions
    # This is problematic for all MPAS components except MPAS-Atmosphere which has valid data everywhere
    # Non-computed regions include, e.g., open ocean in MPAS-Seaice
    # Simply adding a _FillValue to the variable does not, by itself, change this
    # The _FillValue needs to be written in appropriate gridcells
    # The MPAS epic on improving CF-compliance will eventually do that
    # Until then, automatically invoke add_fll on MPAS datasets (except MPAS-A) to mask "uncomputed" regions
    # For MPAS-Ocean, this masks continents/islands
    # For MPAS-Seaice, this additionally masks open (non-sea-ice-covered) ocean
    # For MPAS-Landice (MALI), this masks (I think) non-glacier land and ocean gridcells
    if [ "${prc_typ}" != 'mpasa' ]; then
	add_fll='Yes'
    fi # !mpasa

    # Add depth coordinate to MPAS file when requested to by specifying coordinate file, that file exists, and commmand is found
    if [ -n "${dpt_fl}" ] || [ "${dpt_flg}" = 'Yes' ]; then
	if [ -n "${dpt_fl}" ]; then
	    if [ ! -f "${dpt_fl}" ] && [ ! -L "${dpt_fl}" ]; then
		echo "ERROR: Unable to find specified MPAS depth coordinate file ${dpt_fl}"
		exit 1
	    fi # ! -f
	    cmd_dpt_opt="-c \"${dpt_fl}\""
	fi # !dpt_fl
	if [ -z "${cmd_dpt_mpas}" ]; then
	    printf "${spt_nm}: ERROR MPAS depth coordinate addition requested but command ${dpt_exe_mpas} not found\n"
	fi # !err
	dpt_flg='Yes'
    fi # !dpt_fl
    if [ -z "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then
#	pdq_opt='-a Time,nVertLevels,nIsoLevelsT,nIsoLevelsZ,nCells' # MPAS-Atmosphere
#	pdq_opt='-a Time,nVertLevels,maxEdges,MaxEdges2,nEdges,nCells' # MPAS-Ocean
#	pdq_opt='-a Time,nCategories,ONE,nEdges,nCells' # MPAS-SeaIce
#	pdq_opt='-a Time,nVertInterfaces,nCells' # 20210226: MALI
#	pdq_opt='-a Time,depth,nVertInterfaces,nVertLevels,nVertLevelsP1,maxEdges,MaxEdges2,nCategories,ONE,TWO,nEdges,nCells' # MPAS LI,O,SI and depth
#	pdq_opt='-a Time,depth,nVertInterfaces,nVertLevels,nVertLevelsP1,maxEdges,MaxEdges2,nCategories,R3,ONE,TWO,FOUR,nEdges,nCells' # 20190806: MPAS LI,O,SI,depth and BGC in one swell foop
#	pdq_opt='-a Time,depth,nVertInterfaces,nVertLevels,nVertLevelsP1,nZBGCTracers,nBioLayersP1,nAlgaeIceLayers,nDisIronIceLayers,nIceLayers,nSnowLayers,maxEdges,MaxEdges2,nCategories,R3,ONE,TWO,FOUR,nEdges,nCells' # 20210226: MPAS LI,O,SI,depth and new SI BGC in one swell foop
#        pdq_opt='-a Time,time,depth,nVertInterfaces,nVertLevelsP1,olevhalf,nVertLevels,nZBGCTracers,nBioLayers,P1,nAlgaeIceLayers,nDisIronIceLayers,nIceLayers,nSnowLayers,maxEdges,MaxEdges2,nCategories,R3,ONE,TWO,FOUR,nEdges,nCells' # 20221115: MPAS LI, O, SI, depth, BGC, and CMOR
        pdq_opt='-a Time,time,depth,PRESSURE,nVertInterfaces,nVertLevelsP1,olevhalf,nVertLevels,nZBGCTracers,nBioLayers,P1,nAlgaeIceLayers,nDisIronIceLayers,nIceLayers,nIsoLevelsT,nIsoLevelsZ,nSnowLayers,maxEdges,MaxEdges2,nCategories,R3,ONE,TWO,FOUR,nEdges,nCells' # 20221115: MPAS A, LI, O, SI, depth, ARGO, BGC, CMOR
    fi # !pdq_opt && !pdq_flg
    # 20181130 No known reason to include staggered grid with regridded MPAS data
    stg_grd='No'
fi # !mpas
if [ -n "${rnr_thr}" ]; then 
    if [ "${rnr_thr}" != 'off' ] && [ "${rnr_thr}" != 'none' ]; then 
	rgr_opt="${rgr_opt} --rnr_thr=${rnr_thr}"
    fi # !rnr_thr
elif [ -z "${prs_stt}" ] && [ "${prc_mpas}" = 'Yes' ]; then 
    # Default MPAS behavior (since forever) has been to renormalize
    rgr_opt="${rgr_opt} --rnr_thr=0.0"
fi # !rnr_thr
if [ "${stg_grd}" = 'Yes' ]; then 
    rgr_opt="${rgr_opt} --rgr stg_grd"
fi # !stg_grd
if [ "${prc_typ}" = 'mwf' ]; then 
    [[ ${dbg_lvl} -ge 1 ]] && date_mwf=$(date +"%s")
    # Replace commas with spaces so alg_lst works in for loop:
    alg_lst=$(echo ${alg_lst} | sed 's/,/ /g')
    # Assume destination grid-files that end in .nc are SCRIP (and thus FV), and .g means Exodus (and possibly SE)
    # 20210519: TR input files are increasingly used including .g FV files, so this assumption untenable
    # An independent option to distinguish FV from SE files would be useful
    # https://stackoverflow.com/questions/407184/how-to-check-the-extension-of-a-filename-in-a-bash-script
    # Compute forward (src->dst) maps 
    if [ -n "${hnt_src}" ]; then
       hnt_src_sng="--hnt_src=${hnt_src}"
    fi # !hnt_src
    if [ -n "${hnt_dst}" ]; then
       hnt_dst_sng="--hnt_dst=${hnt_dst}"
    fi # !hnt_dst	
    for alg_typ in ${alg_lst}; do
	if [[ ${grd_src} == *.g ]] || [[ ${grd_dst} == *.g ]]; then
	    if [ ${alg_typ} == 'ncoaave' ] || [ ${alg_typ} == 'ncoidw' ]; then
		continue
	    fi # !alg_typ
	fi # !grd_src
	alg_sng=${alg_typ}
	[[ ${alg_typ} = 'fv2se_flx' ]] && alg_sng='monotr'
	[[ ${alg_typ} = 'fv2se_stt' ]] && alg_sng='highorder'
	[[ ${alg_typ} = 'fv2se_alt' ]] && alg_sng='mono'
	map_nm="${drc_out}/map_${nm_src}_to_${nm_dst}_${alg_sng}.${dt_sng}.nc"
	wgt_sng=''
	if [ -n "${wgt_usr}" ]; then 
	    erwg_alg_typ_rx='aave blin ndtos nstod patc'
	    # https://stackoverflow.com/questions/229551/string-contains-a-substring-in-bash
	    if [[ ${erwg_alg_typ_rx} = *"${alg_typ}"* ]]; then
		wgt_sng="--wgt_cmd='${wgt_usr}'"
	    fi # !ERWG
	fi # !wgt_usr
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    printf "MWF: Create ${alg_typ} map ${map_nm}\n"
	fi # !vrb_lvl
	cmd_mwf="ncremap ${wgt_sng} --alg_typ=${alg_typ} --grd_src=\"${grd_src}\" --grd_dst=\"${grd_dst}\" ${hnt_src_sng} ${hnt_dst_sng} --map_fl=\"${map_nm}\""
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_mwf}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_mwf}
	    if [ "$?" -ne 0 ]; then
		printf "${spt_nm}: ERROR Failed to generate MWF map. Debug this:\n${cmd_mwf}\n"
		exit 1
	    fi # !err
	fi # !dbg
	if [ ${dbg_lvl} -ge 1 ] && [ ${dbg_lvl} -ne 2 ]; then
	    date_crr=$(date +"%s")
	    date_dff=$((date_crr-date_mwf))
	    echo "Elapsed time to generate ${alg_typ} map $((date_dff/60))m$((date_dff % 60))s"
	fi # !dbg
    done # !alg_typ
    # Compute reverse (dst->src) maps
    if [ -n "${hnt_src}" ]; then 
       hnt_dst_sng="--hnt_dst=${hnt_src/src/dst}"
    fi # !hnt_src
    if [ -n "${hnt_dst}" ]; then
       hnt_src_sng="--hnt_src=${hnt_dst/dst/src}"
    fi # !hnt_dst	
    for alg_typ in ${alg_lst}; do
	if [[ ${grd_src} == *.g ]] || [[ ${grd_dst} == *.g ]]; then
	    if [ ${alg_typ} == 'ncoaave' ] || [ ${alg_typ} == 'ncoidw' ]; then
		continue
	    fi # !alg_typ
	fi # !grd_src
	# Swap grd_src with grd_dst
	alg_sng=${alg_typ}
	[[ ${alg_typ} = 'se2fv_flx' ]] && alg_sng='mono'
	[[ ${alg_typ} = 'se2fv_stt' ]] && alg_sng='highorder'
	[[ ${alg_typ} = 'se2fv_alt' ]] && alg_sng='intbilin'
	map_nm="${drc_out}/map_${nm_dst}_to_${nm_src}_${alg_sng}.${dt_sng}.nc"
	# MWF-mode must be invoked with ocean as grd_src, atmosphere as grd_dst
	a2o_sng=''
	if [ "${alg_typ}" = 'se2fv_flx' ] || [ "${alg_typ}" = 'se2fv_stt' ] || [ "${alg_typ}" = 'se2fv_alt' ] || [ "${alg_typ}" = 'traave' ] || [ "${alg_typ}" = 'trbilin' ] || [ "${alg_typ}" = 'trfv2' ] || [ "${alg_typ}" = 'trintbilin' ]; then
	    a2o_sng='--a2o'
	fi # !alg_typ
	wgt_sng=''
	if [ -n "${wgt_usr}" ]; then 
	    erwg_alg_typ_rx='aave blin ndtos nstod patc'
	    # https://stackoverflow.com/questions/229551/string-contains-a-substring-in-bash
	    if [[ ${erwg_alg_typ_rx} = *"${alg_typ}"* ]]; then
		wgt_sng="--wgt_cmd='${wgt_usr}'"
	    fi # !ERWG
	fi # !wgt_usr
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    printf "MWF: Create ${alg_typ} map ${map_nm}\n"
	fi # !vrb_lvl
	cmd_fwm="ncremap ${wgt_sng} ${a2o_sng} --alg_typ=${alg_typ} --grd_src=\"${grd_dst}\" --grd_dst=\"${grd_src}\" ${hnt_src_sng} ${hnt_dst_sng} --map_fl=\"${map_nm}\""
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_fwm}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_fwm}
	    if [ "$?" -ne 0 ]; then
		printf "${spt_nm}: ERROR Failed to generate FWM map. Debug this:\n${cmd_fwm}\n"
		exit 1
	    fi # !err
	fi # !dbg
	if [ ${dbg_lvl} -ge 1 ] && [ ${dbg_lvl} -ne 2 ]; then
	    date_crr=$(date +"%s")
	    date_dff=$((date_crr-date_mwf))
	    echo "Elapsed time to generate ${alg_typ} map $((date_dff/60))m$((date_dff % 60))s"
	fi # !dbg
    done # !alg_typ
    echo "Finished MWF mode"
    exit 0
fi # !mwf
if [ "${prc_typ}" = 'rrg' ]; then 
    if [ -n "${dat_rgn}" ]; then # NB: option currently not implemented, drop it?
	fl_in[0]=${dat_rgn}
    fi # !dat_glb
    if [ -n "${dat_glb}" ]; then 
	if [ ! -f "${dat_glb}" ] && [ ! -L "${dat_glb}" ]; then
	    echo "ERROR: Unable to find specified global data file ${dat_glb}"
	    exit 1
	fi # ! -f
    else
	echo "${spt_nm}: ERROR Regional regridding requires global data coordinates in file specified with --rrg_dat_glb argument\n"
	exit 1
    fi # !dat_glb
    if [ -n "${grd_glb}" ]; then 
	if [ ! -f "${grd_glb}" ] && [ ! -L "${grd_glb}" ]; then
	    echo "ERROR: Unable to find specified SCRIP-format global grid file ${grd_glb}"
	    exit 1
	fi # ! -f
    else
	echo "${spt_nm}: ERROR Regional regridding requires SCRIP-format grid for global data in file specified with --rrg_grd_glb argument\n"
	exit 1
    fi # !grd_glb
    # User may specify final, regional destination grid with either -g or --rrg_grd_rgn
    if [ -n "${grd_rgn}" ]; then 
	grd_dst=${grd_rgn}
    else
	if [ -n "${grd_dst}" ]; then 
	    grd_rgn=${grd_dst}
	else
	    echo "${spt_nm}: ERROR Regional regridding requires SCRIP-format destination grid for regional data in file specified with --rrg_grd_rgn or --grd_dst argument\n"
	    exit 1
	fi # !grd_dst
    fi # !grd_rgn
    if [ ! -f "${grd_rgn}" ] && [ ! -L "${grd_rgn}" ]; then
	echo "ERROR: Unable to find specified SCRIP-format regional grid file ${grd_rgn}"
	exit 1
    fi # ! -f
    grd_dst_usr_flg='Yes'
    hnt_dst='--dst_regional'
fi # !rrg
if [ "${prc_typ}" = 'eamxx' ]; then 
    if [ -z "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then
	# Permute horizontal dimensions to MRV
	# dim2 (= 2) is used in SCREAM SurfVars to store U,V components in horiz_winds, surf_mom_flux variables
	# 20240110: EAMXX also uses dim2 dimension for time_bnds
	#pdq_opt='-a ilev,lev,dim2,ncol'
	# 20230304: EAMxx may have been vertically interpolated to pure-pressure levels prior to horizontal regridding
	#pdq_opt='-a ilev,lev,plev,dim2,ncol'
	# 20241002: EAMxx may have COSP dimensions in order cosp_tau,cosp_cth or cosp_tau,cosp_prs, and spectral dimensions lwband,swband
	pdq_opt='-a time,lwband,swband,ilev,lev,plev,cosp_tau,cosp_cth,cosp_prs,dim2,ncol'
	# NB: ncpdq is invoked iff performing horizontal regridding (vertical interpolation works fine either way)
    fi # !pdq_opt && !pdq_flg
    if [ -z "${ps_nm}" ]; then
	ps_nm='ps'
    fi # !ps_nm
fi # !eamxx
if [ "${prc_typ}" = 'clm' ] || [ "${prc_typ}" = 'ctsm' ] || [ "${prc_typ}" = 'elm' ]; then 
    # Set CLM/ELM-specific options first, then change prc_typ to sgs
    # 20220129 sgs_frc is special since ncclimo may supply it (terminating a filename, even)
    # Hence must keep user-specified sgs_frc value, if any, intact
    rds_rth='6.37122e6' # [m] Radius of Earth in CLM/CTSM/ELM (SHR_CONST_REARTH)
    if [ -n "${sgs_frc_usr}" ]; then sgs_frc="${sgs_frc_usr}"; else sgs_frc='landfrac'; fi
    sgs_msk='landmask'
    sgs_nrm='1.0'
    prc_elm='Yes'
fi # !clm, !ctsm, !elm
if [ "${prc_typ}" = 'cice' ]; then 
    # Set CICE-specific options first, then change prc_typ to sgs
    rds_rth='6371229.0' # [m] Radius of Earth in MPAS-SeaIce (global attribute sphere_radius)
    if [ -n "${sgs_frc_usr}" ]; then sgs_frc="${sgs_frc_usr}"; else sgs_frc='aice'; fi
    sgs_msk='tmask'
    sgs_nrm='100.0'
    prc_cice='Yes'
    add_fll='Yes'
fi # !cice
if [ "${prc_typ}" = 'mpascice' ] || [ "${prc_typ}" = 'mpasseaice' ] || [ "${prc_typ}" = 'mpassi' ]; then 
    # NB: 'mpasseaice' is an exact synonym for 'mpascice' (which is deprecated)
    # Set MPAS-SeaIce-specific options first, then change prc_typ to sgs
    # MPAS-SeaIce requires two modes, MPAS and SGS, so set prc_mpas to 'Yes'
    rds_rth='6371229.0' # [m] Radius of Earth in MPAS-SeaIce (global attribute sphere_radius)
    if [ -n "${sgs_frc_usr}" ]; then sgs_frc="${sgs_frc_usr}"; else sgs_frc='timeMonthly_avg_iceAreaCell'; fi
    # 20190326 timeMonthly_avg_icePresent contains fraction of time in averaging interval when any ice was present
    # Thus timeMonthly_avg_icePresent is a floating point fraction, not a traditional integer mask
    # 20190910 timeMonthly_avg_icePresent should be SGS regridded like any 2D field
    # Treat a field named timeMonthly_avg_icePresentIntMask, if present, as a traditional integer mask
    sgs_msk='timeMonthly_avg_icePresentIntMask'
    sgs_nrm='1.0'
    prc_mpas='Yes'
    prc_mpasseaice='Yes'
fi # !mpascice
if [ -n "${add_fll_usr}" ]; then add_fll="${add_fll_usr}"; fi
if [ "${add_fll}" = 'Yes' ]; then 
    rgr_opt="${rgr_opt} --rgr add_fill_value"
fi # !add_fll
if [ "${mpt_mss}" = 'Yes' ]; then
    rgr_opt="${rgr_opt} --rgr mpt_mss"
fi # !mpt_mss
if [ -n "${sgs_frc}" ] || [ -n "${sgs_frc_usr}" ] || [ "${prc_typ}" = 'sgs' ]; then 
    prc_sgs='Yes'
fi # !sgs
if [ "${prc_sgs}" = 'Yes' ]; then
    if [ -n "${sgs_frc_usr}" ]; then sgs_frc="${sgs_frc_usr}"; fi
    if [ -z "${sgs_frc}" ]; then
	echo "ERROR: SGS processing invoked without specifying sgs_frc variable name"
        echo "HINT: Specify sgs_frc variable name with --sgs_frc=var_name"
        exit 1
    fi # !sgs_frc
    rgr_opt="${rgr_opt} --rgr sgs_frc_nm=${sgs_frc}"
    if [ -n "${sgs_msk}" ]; then
	rgr_opt="${rgr_opt}#sgs_msk_nm=${sgs_msk}"
    fi # !sgs_msk
    if [ -n "${sgs_nrm}" ]; then
	rgr_opt="${rgr_opt}#sgs_nrm=${sgs_nrm}"
    fi # !sgs_nrm
fi # !prc_sgs
if [ -n "${thr_usr}" ]; then 
    thr_nbr="${thr_usr}"
fi # !thr_usr
if [ -n "${vrt_out}" ]; then
    if [ ! -f "${vrt_out}" ] && [ ! -L "${vrt_out}" ]; then
	echo "ERROR: Unable to find specified vertical output grid file ${vrt_out}"
	exit 1
    fi # ! -f
    vrt_usr_flg='Yes'
    if [ -n "${dpt_nm}" ]; then
	vrt_opt="${vrt_opt} --rgr dpt_nm_in=${dpt_nm}"
    fi # !dpt_nm
    if [ -n "${ps_nm}" ]; then
	vrt_opt="${vrt_opt} --rgr ps_nm_in=${ps_nm}"
    fi # !ps_nm
    if [ "${ps_rtn}" = 'Yes' ]; then
	vrt_opt="${vrt_opt} --rgr ps_rtn"
    fi # !ps_rtn
    if [ -n "${vrt_in}" ]; then
	if [ ! -f "${vrt_in}" ] && [ ! -L "${vrt_in}" ]; then
	    echo "ERROR: Unable to find specified vertical input grid file ${vrt_in}"
	    exit 1
	fi # ! -f
	vrt_opt="${vrt_opt} --rgr vrt_in=${vrt_in}"
    fi # !vrt_in
    if [ -n "${vrt_nm}" ]; then
	vrt_opt="${vrt_opt} --rgr plev_nm_in=${vrt_nm}"
    fi # !vrt_nm
    if [ -n "${vrt_xtr}" ]; then
	if [ ${vrt_xtr} = 'mss_val' ] || [ ${vrt_xtr} = 'missing_value' ] || [ ${vrt_xtr} = 'msv' ]; then 
	    vrt_opt="${vrt_opt} --rgr xtr_mth=mss_val"
	elif [ ${vrt_xtr} = 'nrs_ngh' ] || [ ${vrt_xtr} = 'nearest_neighbor' ] || [ ${vrt_xtr} = 'nn' ]; then 
	    vrt_opt="${vrt_opt} --rgr xtr_mth=nrs_ngh"
	elif [ ${vrt_xtr} = 'linear' ] || [ ${vrt_xtr} = 'lnr' ] || [ ${vrt_xtr} = 'lin' ]; then 
	    vrt_opt="${vrt_opt} --rgr xtr_mth=linear"
	elif [ ${vrt_xtr} = 'zero' ] || [ ${vrt_xtr} = 'nil' ]; then 
	    vrt_opt="${vrt_opt} --rgr xtr_mth=zero"
	else 
	    echo "${spt_nm}: ERROR ${vrt_xtr} is not a valid extrapolation method"
	    echo "${spt_nm}: HINT Valid vertical extrapolation methods and synonyms are: linear,lnr,lin | mss_val,missing_value,msv | nrs_ngh,nearest_neighbor,nn | zero,nil"
	    exit 1
	fi # !vrt_xtr
    fi # !vrt_xtr
    if [ -n "${vrt_ntp}" ]; then
	if [ ${vrt_ntp} = 'lin' ] || [ ${vrt_ntp} = 'linear' ] || [ ${vrt_ntp} = 'lnr' ]; then 
	    vrt_opt="${vrt_opt} --rgr ntp_mth=lin"
	elif [ ${vrt_ntp} = 'log' ] || [ ${vrt_ntp} = 'logarithmic' ] || [ ${vrt_ntp} = 'lgr' ]; then 
	    vrt_opt="${vrt_opt} --rgr ntp_mth=log"
	else 
	    echo "${spt_nm}: ERROR ${vrt_ntp} is not a valid interpolation method"
	    echo "${spt_nm}: HINT Valid vertical interpolation methods and synonyms are lin,linear,lnr | log,logarithmic,lgr"
	    exit 1
	fi # !vrt_ntp
    fi # !vrt_ntp
fi # !vrt_out

if [ -n "${dst_fl}" ]; then 
    if [ ! -f "${dst_fl}" ] && [ ! -L "${dst_fl}" ]; then
	echo "ERROR: Unable to find specified destination-file ${dst_fl}"
	echo "HINT: Supply the full path-name for the destination-file"
	exit 1
    fi # ! -f
    dst_usr_flg='Yes'
fi # !dst_fl
if [ -z "${grd_sng}" ]; then 
    grd_sng_dfl="grd_ttl='Default internally-generated grid'#latlon=10,10#lat_typ=uni#lon_typ=Grn_ctr" # [sng] Grid string default
    grd_sng="${grd_sng_dfl}"
else
    grd_sng_usr_flg='Yes'
fi # !grd_sng
if [ -n "${grd_dst}" ]; then 
    if [ -f "${grd_dst}" ] || [ -L "${grd_dst}" ]; then
	if [ "${dst_usr_flg}" = 'Yes' ]; then
	    printf "${spt_nm}: WARNING ${grd_dst} already exists and will be overwritten by newly inferred grid\n"
	fi # !dst_usr_flg
	if [ "${grd_sng_usr_flg}" = 'Yes' ]; then
	    printf "${spt_nm}: WARNING ${grd_dst} already exists and will be overwritten by newly created grid\n"
	fi # !grd_sng_usr_flg
    else
	if [ "${dst_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ]; then
	    echo "ERROR: Unable to find specified destination grid-file ${grd_dst}"
	    echo "HINT: Supply full path-name for destination grid, or generate it with -G option and arguments"
	exit 1
	fi # !dst_usr_flg
    fi # ! -f
    grd_dst_usr_flg='Yes'
else
    grd_dst=${grd_dst_dfl} # [sng] Grid-file default
fi # !grd_dst
if [ -n "${grd_src}" ]; then 
    if [ "${prc_typ}" != 'rrg' ]; then 
	if [ ! -f "${grd_src}" ] && [ ! -L "${grd_src}" ]; then
	    echo "ERROR: Unable to find specified source grid-file ${grd_src}"
	    exit 1
	fi # ! -f
	grd_src_usr_flg='Yes'
    fi # !rrg
else
    grd_src=${grd_src_dfl} # [sng] Grid-file default
fi # !grd_src
if [ "${dst_usr_flg}" = 'Yes' ] || [ "${grd_sng_usr_flg}" = 'Yes' ] || [ "${grd_dst_usr_flg}" = 'Yes' ] || [ "${grd_src_usr_flg}" = 'Yes' ]; then
    # Create map-file if -d, -G, -g, or -s was specified
    map_mk='Yes'
fi # !map_mk
if [ -n "${map_fl}" ]; then 
    map_usr_flg='Yes'
    if [ "${map_mk}" = 'Yes' ]; then
	# Confirm before overwriting maps
        if [ -f "${map_fl}" ] || [ -L "${map_fl}" ]; then
	    # 20160803: fxm invoke iff in interactive shell (block hangs on read() in non-interactive shells)
#	    if [ -t 0 ] || [ ! -p /dev/stdin ]; then
#           if [ -n "${TERM}" ]; then
#           if [ -n "${PS1}" ]; then
            if [ 1 -eq 0 ]; then
		rsp_kbd_nbr=0
		while [ ${rsp_kbd_nbr} -lt 10 ]; do
		    echo "WARNING: Map-file ${map_fl} already exists and will be over-written."
		    read -p "Continue (y/n)? " rsp_kbd
		    let rsp_kbd_nbr+=1
		    case "${rsp_kbd}" in
			N*|n*) exit 1 ;;
			Y*|y*) break ;;
			*) continue ;;
		    esac
		done # !rsp_kbd_nbr
		if [ ${rsp_kbd_nbr} -ge 10 ]; then
		    echo "ERROR: Too many invalid responses, exiting"
		    exit 1
		fi # !rsp_kbd_nbr
	    fi # !0
	fi # !map_fl
    else # !map_mk
        if [ ! -f "${map_fl}" ] && [ ! -L "${map_fl}" ]; then
	    echo "ERROR: Unable to find specified regrid map ${map_fl}"
	    echo "HINT: Supply a valid map-file (weight-file) name or supply the grid files or data files and let ncremap create a mapfile for you"
	    exit 1
	fi # ! -f
    fi # !map_mk
else # !map_fl
    map_fl_dfl="${drc_tmp}/ncremap_tmp_map_${wgt_typ}_${alg_opt}.nc${unq_sfx}" # [sng] Map-file default
    map_fl=${map_fl_dfl}
fi # !map_fl
map_rsl_fl=${map_fl}
if [ "${map_mk}" = 'Yes' ]; then
    if [ "${wgt_typ}" = 'nco' ]; then
	msh_fl_dfl="${drc_tmp}/ncremap_tmp_msh_ovr_${wgt_typ}.nc${unq_sfx}" # [sng] Mesh-file default
    elif [ "${wgt_typ}" = 'tempest' ]; then 
	msh_fl_dfl="${drc_tmp}/ncremap_tmp_msh_ovr_${wgt_typ}.g${unq_sfx}" # [sng] Mesh-file default
	if [ "${trn_map}" = 'Yes' ]; then
	    map_trn_fl="${drc_tmp}/ncremap_tmp_map_trn_${wgt_typ}.nc${unq_sfx}" # [sng] Map-file transpose default
	    map_rsl_fl=${map_trn_fl}
	fi # !trn_map
    fi # !tempest
    if [ -n "${msh_fl}" ] && [ "${wgt_typ}" = 'nco' ]; then
	msh_opt="--rgr msh=\"${msh_fl}\""
    else
	msh_fl=${msh_fl_dfl}
    fi # !msh_fl_usr
fi # !map_mk

# Read files from stdin pipe, positional arguments, or directory glob
# Code block taken from ncclimo
# ncclimo sets inp_aut flag when file list is automatically (i.e., internally) generated
# ncremap uses convention that input files specified with -i set inp_aut flag
# That way, ncremap code block looks closer to ncclimo without introducing a new "inp_cmd" flag
#printf "dbg: inp_aut  = ${inp_aut}\n"
#printf "dbg: inp_glb  = ${inp_glb}\n"
#printf "dbg: inp_psn  = ${inp_psn}\n"
#printf "dbg: inp_std  = ${inp_std}\n"
if [ ${inp_aut} = 'No' ] && [ ${inp_psn} = 'No' ] && [ ${inp_std} = 'No' ] && [ "${drc_in_usr_flg}" = 'Yes' ]; then
    inp_glb='Yes'
fi # !inp_psn, !inp_std
if [ "${map_mk}" != 'Yes' ] && [ ${inp_aut} = 'No' ] && [ ${inp_glb} = 'No' ] && [ ${inp_psn} = 'No' ] && [ ${inp_std} = 'No' ]; then
    echo "${spt_nm}: ERROR Specify input file(s) with -i \$in_fl or with -I \$drc_in or with positional argument(s) or with stdin"
    if [ ${bch_pbs} = 'Yes' ]; then
	echo "${spt_nm}: HINT PBS batch job environment detected, pipe to stdin not allowed, try positional arguments instead"
    else # !bch_pbs
	echo "${spt_nm}: HINT Pipe input file list to stdin with, e.g., 'ls *.nc | ${spt_nm}'"
    fi # !bch_pbs
    exit 1
fi # !sbs_flg
if [ ${inp_aut} = 'Yes' ]; then 
    # Single file argument
    fl_in[0]=${in_fl}
    fl_nbr=1
fi # !inp_aut
if [ ${inp_glb} = 'Yes' ]; then 
    for fl in "${drc_in}"/*.nc "${drc_in}"/*.nc3 "${drc_in}"/*.nc4 "${drc_in}"/*.cdf "${drc_in}"/*.hdf "${drc_in}"/*.he5 "${drc_in}"/*.h5 ; do
	if [ -f "${fl}" ] || [ -L "${fl}" ]; then
	    fl_in[${fl_nbr}]=${fl} # NB: ncremap does not use basename($fl) like ncclimo
	    let fl_nbr=${fl_nbr}+1
	fi # !file
    done
fi # !inp_glb
if [ ${inp_psn} = 'Yes' ]; then
    if [ ${psn_nbr} -eq 1 ]; then
	fl_in[0]=${1}
	fl_nbr=1
    elif [ ${psn_nbr} -eq 2 ]; then
	if [ -z "${out_fl}" ]; then
	    fl_in[0]=${1}
	    out_fl=${2}
	    out_usr_flg='Yes'
	    fl_nbr=1
	else # !out_fl
	    echo "ERROR: Output file specified with -o (${out_fl}) conflicts with second positional argument ${2}"
	    echo "HINT: Use -o out_fl or positional argument, not both"
	    exit 1
	fi # !out_fl
    elif [ ${psn_nbr} -ge 3 ]; then
	for ((psn_idx=1;psn_idx<=psn_nbr;psn_idx++)); do
	    fl_in[(${psn_idx}-1)]=${!psn_idx}
	    fl_nbr=${psn_nbr}
	done # !psn_idx
    fi # !psn_nbr
fi # !inp_psn
if [ ${inp_std} = 'Yes' ]; then
    # Input awaits on unit 0, i.e., on stdin
    while read -r line; do # NeR05 p. 179
	fl_in[${fl_nbr}]=${line}
	let fl_nbr=${fl_nbr}+1
    done < /dev/stdin
fi # !inp_std

# 20231214 Retain multidimensional auxiliary coordinates as needed for vertical (not horizontal) interpolation
if [ "${prc_typ}" = 'mpaso' ] || [ "${prc_typ}" = 'mpasocean' ]; then
    if [ -n "${vrt_out}" ]; then
	if [ -n "${nco_var_lst}" ] && [ "${xcl_flg}" != 'Yes' ]; then
	    # Search the file iff the extraction list does not already contain the depth coordinate
	    # https://stackoverflow.com/questions/4542732/how-do-i-negate-a-test-with-regular-expressions-in-a-bash-script
	    if [[ ! "${nco_var_lst}" =~ ${mpaso_var_zmid} ]]; then
		mpaso_var_lst=`nchasvar ${mpaso_var_zmid} ${fl_in[0]}`
		if [ "${mpaso_var_lst}" = ${mpaso_var_zmid} ]; then
		    nco_var_lst="${nco_var_lst},${mpaso_var_zmid}"
		    # Alternatively, could create nco_var_lst_ncpdq to ensure ncpdq retains mpaso_var_zmid so vertical
		    # interpolation finds it, yet it does not appear in horizontal regridding namelist
		    #		    echo "DEBUG: Added ${mpaso_var_zmid} to extraction list: nco_var_lst = ${nco_var_lst}"
		fi # !mpaso_var_lst
	    fi # !nco_var_lst
	fi # !nco_var_lst, !xcl_flg
    fi # !vrt_out
fi # !mpaso

if [ "${mpi_flg}" = 'Yes' ]; then
    if [ -n "${PBS_NODEFILE}" ]; then 
	nd_fl="${PBS_NODEFILE}"
    elif [ -n "${SLURM_NODELIST}" ]; then 
	# SLURM returns compressed lists (e.g., "nid00[076-078,559-567]")
	# Convert this to file with uncompressed list (like PBS)
	# http://www.ceci-hpc.be/slurm_faq.html#Q12
	# Ensure file is in writable directory
	nd_fl="${drc_out}/${spt_nm}.slurm_nodelist.pid${spt_pid}.tmp"
	nd_lst=`scontrol show hostname ${SLURM_NODELIST}`
	echo ${nd_lst} > ${nd_fl}
    else
	echo "${spt_nm}: ERROR MPI master process unable to find node-list for distributing jobs"
	echo "${spt_nm}: ${spt_nm} uses first node-list found in \$PBS_NODEFILE or \$SLURM_NODELIST"
	echo "${spt_nm}: However, none of these environment variables are set so there is no node-list for distributing MPI jobs"
	echo "${spt_nm}: HINT: Requesting MPI-parallelism (i.e., invoking ${spt_nm} with \"-p mpi\") in a non-MPI environment will trigger this error. Use \"-p mpi\" only when one of the preceding schedulers has allocated (for interactive use) or will allocate (for non-interactive use) the compute nodes. Otherwise use the default background parallelism (use \"-p bck\" or omit the option completely) or use serial mode (use \"-p serial\"). See http://nco.sf.net/nco.html#par_typ for more information on parallelism."
	exit 1
    fi # !PBS
    # 20210310 MPI run command may need/use thr_nbr so set it first
    if [ -z "${thr_usr}" ]; then 
	if [ -n "${PBS_NUM_PPN}" ]; then
#	NB: use export OMP_NUM_THREADS when thr_nbr > 8
#	thr_nbr=${PBS_NUM_PPN}
	    thr_nbr=$((PBS_NUM_PPN > 8 ? 8 : PBS_NUM_PPN))
	fi # !pbs
    fi # !thr_usr
    if [ -n "${nd_fl}" ]; then 
	# NB: nodes are 0-based, e.g., [0..11]
	nd_idx=0
	for nd in `cat ${nd_fl} | uniq` ; do
	    nd_nm[${nd_idx}]=${nd}
	    let nd_idx=${nd_idx}+1
	done # !nd
	nd_nbr=${#nd_nm[@]}
	if [ "${nd_nbr}" -eq 0 ]; then
	    echo "${spt_nm}: ERROR MPI-mode node number nd_nbr = ${nd_nbr}"
	    echo "${spt_nm}: HINT Parsing the node-list for distributing MPI jobs failed"
	    exit 1
	fi # !nd_nbr
	# NB: ncclimo and ncremap employ different node-allocation algorithms:
	# ncclimo (monthly climatology mode) assigns monthly regridding and seasonal climos to different nodes (i.e., load-balances), and likewise for seasonal-regridding and annual climo
	# ncclimo (splitter mode) uses simple round robin based on position in variable list
	# ncremap uses simple round-robin allocation based on position in input file list
	# Only ncclimo monthly climatology-mode uses 1-based cmd_mpi array
	# ncclimo splitter-mode, and daily and annual climatology-mode, and ncremap all use 0-based cmd_mpi array
	# Copy host-specific mpirun syntax but not node-allocation algorithms or loop indices between ncclimo and ncremap
	# 20160502: Remove tasks-per-node limits (ntasks, npernode) so round-robin algorithm can schedule multiple jobs on same node
	for ((fl_idx=0;fl_idx<fl_nbr;fl_idx++)); do
	    case "${HOSTNAME}" in 
		andes* | blues* | blogin* | b[0123456789][0123456789][0123456789] | chrysalis* | chrlogin* | chr-[0123456789][0123456789][0123456789][0123456789] | compy* | constance* | frontier* | login[0123456789][0123456789] | nid* | node* | perlmutter* )
		    # 20220518: Non-interactive batch jobs at NERSC/Perlmutter return HOSTNAME as login??, and nodes as nid??????
		    # 20160803: Non-interactive batch jobs at PNNL constance return HOSTNAME as node*, not constance*
		    # 20190526: Non-interactive batch jobs at PNNL compy return HOSTNAME as n????, not compy*
		    # 20210310: srun option<->long option equivalences are -N = --nodes, -n = --ntasks, -c = --cpus-per-task
		    # NB: NERSC staff says srun automatically assigns to unique nodes even without "-L $node" argument?
 		    cmd_mpi[${fl_idx}]="srun --nodelist ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} --nodes=1" ; ;; # SLURM
		    # cmd_mpi[${fl_idx}]="srun --nodelist ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} --nodes=1 --ntasks=1" ; ;; # SLURM
		    # cmd_mpi[${fl_idx}]="srun --nodelist ${nd_nm[$((${fl_idx_zro} % ${nd_nbr}))]} --nodes=1 --ntasks=1 --cpus-per-task=1" ; ;; # SLURM
		*cheyenne* )
		    # 20180120: Non-interactive batch jobs at NCAR return HOSTNAME as cheyenne?
		    # Cheyenne prefers 'mpiexec_mpt dplace -s 1 ncclimo ...'
		    # Unsure how to specify nd_nm to mpiexec_mpt
		    # mpirun from SGI MPT does not accept '-H nd_nm', unlike regular PBS
		    # PBSPro considers ncclimo a 'non-MPT application' so must set MPI_SHEPHERD=true
		    export MPI_SHEPHERD=true
#		    cmd_mpi[${fl_idx}]="mpiexec_mpt dplace ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # PBSPro
		    cmd_mpi[${fl_idx}]="mpirun ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # PBSPro
		* )
		    cmd_mpi[${fl_idx}]="mpirun -H ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # Other (PBS)
#		    cmd_mpi[${fl_idx}]="mpirun -H ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -npernode 1 -n 1" ; ;; # Other
	    esac # !HOSTNAME
	    case "${HOSTNAME}" in 
		perlmutter* | login[0123456789][0123456789] | nid* )
		    # 20210319: Multiple srun commands cannot run concurrently on single Cori node without special options
		    # --gres=craynetwork:0 --mem=20000 tested by me, Noel Keen documented here:
		    # https://docs.nersc.gov/jobs/examples/#multiple-parallel-jobs-while-sharing-nodes
		    # These options are only expected to work on NERSC Cori
		    # craynetwork:0 (instead of, e.g., :1) allows any number of MPI jobs to run
		    # 20240406 Deprecate --gres=craynetwork:0 since not available on Perlmutter, and keep --mem option
		    # Argument to --mem is requested number of MB RAM per job so 96 GB Cori node with 4 MPI processes can use ~20000 MB RAM per job, and, I think, jobs in excess of that will queue until more RAM becomes available as old jobs finish
		    # 20210319: --zonesort=off tested by me does eliminate zonesort messages like these:
		    # slurmstepd: error: Detected zonesort setup failure: zonesort interface write failure (40558186.7)
		    # However, using zonesort option appears to slow-down throughput considerably
		    cmd_mpi[${fl_idx}]="${cmd_mpi[${fl_idx}]} --mem=${mem_mb}" ; ;; # SLURM    
		    # cmd_mpi[${fl_idx}]="${cmd_mpi[${fl_idx}]} --nodes=1 --gres=craynetwork:0 --mem=${mem_mb} --zonesort=off" ; ;; # SLURM
	    esac # !HOSTNAME
	done # !fl_idx
	if [ -n "${SLURM_NODELIST}" ]; then 
	    /bin/rm -f ${nd_fl}
	fi # !SLURM
    else # !nd_fl
	mpi_flg='No'
	for ((fl_idx=0;fl_idx<fl_nbr;fl_idx++)); do
	    cmd_mpi[${fl_idx}]=''
	done # !fl_idx
    fi # !nd_fl
    if [ -z "${job_usr}" ]; then 
	job_nbr=${nd_nbr}
    fi # !job_usr
fi # !mpi_flg

# Print initial state
if [ ${dbg_lvl} -ge 2 ]; then
    printf "dbg: a2o_flg  = ${a2o_flg}\n"
    printf "dbg: add_fll  = ${add_fll}\n"
    printf "dbg: alg_lst  = ${alg_lst}\n"
    printf "dbg: alg_opt  = ${alg_opt}\n"
    printf "dbg: alg_typ  = ${alg_typ}\n"
    printf "dbg: att_flg  = ${att_flg}\n"
    printf "dbg: cln_flg  = ${cln_flg}\n"
    printf "dbg: cmd_cdo  = ${cmd_wgt_cdo}\n"
    printf "dbg: cmd_esm  = ${cmd_wgt_esmf}\n"
    printf "dbg: cmd_mbt  = ${cmd_wgt_mbt}\n"
    printf "dbg: cmd_nco  = ${cmd_wgt_nco}\n"
    printf "dbg: cmd_tps  = ${cmd_wgt_tps}\n"
    printf "dbg: cmd_tps  = ${cmd_msh_tps}\n"
    printf "dbg: cmp_sng  = ${cmp_sng}\n"
    printf "dbg: col_dmn  = ${col_dmn}\n"
    printf "dbg: d2f_flg  = ${d2f_flg}\n"
    printf "dbg: d2f_opt  = ${d2f_opt}\n"
    printf "dbg: dbg_lvl  = ${dbg_lvl}\n"
    printf "dbg: devnull  = ${devnull}\n"
    printf "dbg: dfl_lvl  = ${dfl_lvl}\n"
    printf "dbg: dpt_flg  = ${dpt_flg}\n"
    printf "dbg: dpt_fl   = ${dpt_fl}\n"
    printf "dbg: dpt_nm   = ${dpt_nm}\n"
    printf "dbg: drc_in   = ${drc_in}\n"
    printf "dbg: drc_out  = ${drc_out}\n"
    printf "dbg: drc_tmp  = ${drc_tmp}\n"
    printf "dbg: dst_fl   = ${dst_fl}\n"
    printf "dbg: erwg_vrs = ${erwg_vrs_sng}\n"
    printf "dbg: esmf_typ = ${esmf_typ}\n"
    printf "dbg: fl_fmt   = ${fl_fmt}\n"
    printf "dbg: fl_in[0] = ${fl_in[0]}\n"
    printf "dbg: fl_nbr   = ${fl_nbr}\n"
    printf "dbg: flg_hrz  = ${flg_hrz}\n"
    printf "dbg: gaa_sng  = ${gaa_sng}\n"
    printf "dbg: gad_sng  = ${gad_sng}\n"
    printf "dbg: grd_dst  = ${grd_dst}\n"
    printf "dbg: grd_sng  = ${grd_sng}\n"
    printf "dbg: grd_src  = ${grd_src}\n"
    printf "dbg: inp_aut  = ${inp_aut}\n"
    printf "dbg: inp_glb  = ${inp_glb}\n"
    printf "dbg: inp_psn  = ${inp_psn}\n"
    printf "dbg: inp_std  = ${inp_std}\n"
    printf "dbg: hdr_pad  = ${hdr_pad}\n"
    printf "dbg: hrd_pth  = ${hrd_pth}\n"
    printf "dbg: hst_att  = ${hst_att}\n"
    printf "dbg: job_nbr  = ${job_nbr}\n"
    printf "dbg: in_fl    = ${in_fl}\n"
    printf "dbg: map_fl   = ${map_fl}\n"
    printf "dbg: map_mk   = ${map_mk}\n"
    printf "dbg: mlt_map  = ${mlt_map_flg}\n"
    printf "dbg: mpi_flg  = ${mpi_flg}\n"
    printf "dbg: mpi_nbr  = ${mpi_nbr}\n"
    printf "dbg: mpi_pfx  = ${mpi_pfx}\n"
    printf "dbg: mpt_mss  = ${mpt_mss}\n"
    printf "dbg: msh_fl   = ${msh_fl}\n"
    printf "dbg: msk_apl  = ${msk_apl}\n"
    printf "dbg: msk_dst  = ${msk_dst}\n"
    printf "dbg: msk_out  = ${msk_out}\n"
    printf "dbg: msk_src  = ${msk_src}\n"
    printf "dbg: nco_opt  = ${nco_opt}\n"
    printf "dbg: nd_nbr   = ${nd_nbr}\n"
    printf "dbg: out_fl   = ${out_fl}\n"
    printf "dbg: par_typ  = ${par_typ}\n"
    printf "dbg: pdq_flg  = ${pdq_flg}\n"
    printf "dbg: pdq_opt  = ${pdq_opt}\n"
    printf "dbg: prc_sgs  = ${prc_sgs}\n"
    printf "dbg: prc_typ  = ${prc_typ}\n"
    printf "dbg: prs_stt  = ${prs_stt}\n"
    printf "dbg: prt_nbr  = ${prt_nbr}\n"
    printf "dbg: ps_nm    = ${ps_nm}\n"
    printf "dbg: ps_rtn   = ${ps_rtn}\n"
#    printf "dbg: qea_flg  = ${qea_flg}\n"
    printf "dbg: qnt_prc  = ${qnt_prc}\n"
    printf "dbg: rgr_opt  = ${rgr_opt}\n"
    printf "dbg: rnr_thr  = ${rnr_thr}\n"
    printf "dbg: rrg_bb   = ${bb_wesn}\n"
    printf "dbg: rrg_dat  = ${dat_glb}\n"
    printf "dbg: rrg_glb  = ${grd_glb}\n"
    printf "dbg: rrg_rgn  = ${grd_rgn}\n"
    printf "dbg: rrg_rnm  = ${rnm_sng}\n"
    printf "dbg: se_np_nbr= ${se_np_nbr}\n"
    printf "dbg: sgs_frc  = ${sgs_frc}\n"
    printf "dbg: sgs_msk  = ${sgs_msk}\n"
    printf "dbg: sgs_nrm  = ${sgs_nrm}\n"
    printf "dbg: skl_fl   = ${skl_fl}\n"
    printf "dbg: spt_nm   = ${spt_nm}\n"
    printf "dbg: spt_pid  = ${spt_pid}\n"
    printf "dbg: std_chk  = ${std_chk}\n"
    printf "dbg: stg_grd  = ${stg_grd}\n"
    printf "dbg: thr_nbr  = ${thr_nbr}\n"
    printf "dbg: ugrid_fl = ${ugrid_fl}\n"
    printf "dbg: uio_flg  = ${uio_flg}\n"
    printf "dbg: unq_sfx  = ${unq_sfx}\n"
    printf "dbg: var_lst  = ${var_lst}\n"
    printf "dbg: var_rgr  = ${var_rgr}\n"
    printf "dbg: vrt_in   = ${vrt_in}\n"
    printf "dbg: vrt_nm   = ${vrt_nm}\n"
    printf "dbg: vrt_opt  = ${vrt_opt}\n"
    printf "dbg: vrt_out  = ${vrt_out}\n"
    printf "dbg: vrt_ntp  = ${vrt_ntp}\n"
    printf "dbg: vrt_xtr  = ${vrt_xtr}\n"
    printf "dbg: wgt_cmd  = ${wgt_cmd}\n"
    printf "dbg: wgt_opt  = ${wgt_opt}\n"
    printf "dbg: wgt_typ  = ${wgt_typ}\n"
    printf "dbg: wgt_usr  = ${wgt_usr}\n"
    printf "dbg: xtr_nsp  = ${xtr_nsp}\n"
    printf "dbg: xtr_xpn  = ${xtr_xpn}\n"
    printf "dbg: Will regrid ${fl_nbr} files:\n"
    for ((fl_idx=0;fl_idx<${fl_nbr};fl_idx++)); do
	printf "\${fl_in[${fl_idx}]} = ${fl_in[${fl_idx}]}\n"
    done # !fl_idx
fi # !dbg
if [ ${dbg_lvl} -ge 2 ]; then
    if [ ${mpi_flg} = 'Yes' ]; then
	for ((nd_idx=0;nd_idx<${nd_nbr};nd_idx++)); do
	    printf "dbg: nd_nm[${nd_idx}] = ${nd_nm[${nd_idx}]}\n"
	done # !nd
    fi # !mpi
fi # !dbg
if [ ${dbg_lvl} -ge 2 ]; then
    psn_nbr=$#
    printf "dbg: Found ${psn_nbr} positional parameters (besides \$0):\n"
    for ((psn_idx=1;psn_idx<=psn_nbr;psn_idx++)); do
	printf "dbg: psn_arg[${psn_idx}] = ${!psn_idx}\n"
    done # !psn_idx
fi # !dbg

# Create output directories
if [ -n "${drc_out}" ] && [ ! -d "${drc_out}" ]; then 
    chr_fst=${drc_out:0:1}
    if [ "${chr_fst}" = '-' ]; then
	echo "${spt_nm}: ERROR Attempting to mkdir user-specified output directory \"${drc_out}\" will fail because directory name begins with '-' which is an option indicator"
	echo "${spt_nm}: HINT Specify output directory name that does not begin with '-'"
	exit 1
    fi # !chr_fst
    cmd_mkd="mkdir -p ${drc_out}"
    eval ${cmd_mkd}
    if [ "$?" -ne 0 ]; then
	printf "${spt_nm}: ERROR Failed to create output directory. Debug this:\n${cmd_mkd}\n"
	printf "${spt_nm}: HINT Creating a directory requires proper write permissions\n"
	exit 1
    fi # !err
fi # !drc_out
if [ -n "${drc_tmp}" ] && [ ! -d "${drc_tmp}" ]; then 
    cmd_mkd="mkdir -p ${drc_tmp}"
    eval ${cmd_mkd}
    if [ "$?" -ne 0 ]; then
	printf "${spt_nm}: ERROR Attempt to create temporary directory. Debug this:\n${cmd_mkd}\n"
	printf "${spt_nm}: HINT Creating a directory requires proper write permissions\n"
	exit 1
    fi # !err
fi # !drc_tmp

# Human-readable summary
date_srt=$(date +"%s")
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    printf "NCO regridder invoked with command:\n"
    echo "${cmd_ln}"
fi # !vrb_lvl
if [ ${dbg_lvl} -ge 2 ]; then
    printf "************************************************************************\n"
    printf "IMPORTANT: This output shows a SIMULATION of a production run\n"
    printf "The values shown are real, but the printed commands are NOT executed\n"
    printf "This output is for debugging purpose only since dbg_lvl = ${dbg_lvl} >= 2\n"
    printf "The elapsed time should be near 0m0s since there is very little disk I/O\n"
    printf "Set dbg_lvl <= 1 for a PRODUCTION RUN that executes these commands\n"
    printf "************************************************************************\n"
fi # !dbg
if [ -f 'PET0.RegridWeightGen.Log' ]; then
    if [ ${vrb_lvl} -ge ${vrb_4} ]; then
	printf "${spt_nm}: Removing PET0.RegridWeightGen.Log file and any other PET0.* files from current directory before running\n"
    fi # !vrb_lvl
    /bin/rm -f PET0.*
fi # !PETO
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    printf "Started processing at `date`.\n"
    printf "Running remap script ${spt_nm} from directory ${drc_spt}\n"
    printf "NCO binaries version ${nco_vrs} from directory ${drc_nco}\n"
    printf "Parallelism mode = ${par_typ}\n"
    if [ ${fl_nbr} -gt 1 ]; then
	if [ "${par_typ}" = ${par_bck} ]; then
	    printf "Background parallelism regridding files in fl_nbr/job_nbr = ${fl_nbr}/${job_nbr} = $((fl_nbr / job_nbr)) sequential batches each concurrently processing job_nbr = ${job_nbr} files\n"
	elif [ "${par_typ}" = ${par_mpi} ]; then
	    printf "MPI parallelism regridding files in fl_nbr/job_nbr = ${fl_nbr}/${job_nbr} = $((fl_nbr / job_nbr)) sequential batches. Each batch is distributed to ${nd_nbr} nodes via round-robin scheduling and handles job_nbr = ${job_nbr} months concurrently.\n"
	else
	    printf "No parallelism--files will be regridded serially (one at a time) on a single node. HINT: to regrid multiple files in parallel, try \'--par_typ=background\' or \'--par_typ=mpi\'\n"
	fi # !par_typ
    fi # !fl_nbr
    printf "Input files in or relative to directory ${drc_in}\n"
    printf "Intermediate/temporary files written to directory ${drc_tmp}\n"
    printf "Output files to directory ${drc_out}\n"
fi # !vrb_lvl
if [ "${map_mk}" != 'Yes' ] && [ "${map_usr_flg}" = 'Yes' ] && [ -n "${wgt_usr}" ]; then
    printf "${spt_nm}: ERROR Specifying both '-m map_fl' and '-w wgt_cmd' is only allowed when creating a map (weight-generator is superfluous when user supplies map)\n"
    exit 1
fi # wgt_usr
    
if [ "${dst_usr_flg}" = 'Yes' ]; then 
    if [ "${grd_dst_usr_flg}" = 'Yes' ]; then 
	printf "${spt_nm}: INFO Both '-d dst_fl' and '-g grd_dst' were specified so ${spt_nm} will infer grid-file ${grd_dst} from data-file ${dst_fl}\n"
    fi # !grd_dst_usr_flg
fi # !dst_usr_flg
if [ "${dst_usr_flg}" != 'Yes' ] && [ "${grd_dst_usr_flg}" != 'Yes' ] && [ "${map_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ] && [ "${vrt_usr_flg}" != 'Yes' ]; then 
    printf "${spt_nm}: ERROR Unable to determine remapping procedure\nHINT: Specify the type of remapping to perform with at least one of the following options: 1) A data/template file, '-d dst_fl'; 2) A destination grid-file, '-g grd_dst'; 3) A grid-construction command, '-G grd_sng'; 4) A map-file with weights to apply, '-m map_fl'; 5) A vertical grid to interpolate to, --vrt_out=vrt_out\n"
    exit 1
fi # !dst_usr_flg
if [ "${dst_usr_flg}" != 'Yes' ] && [ "${grd_dst_usr_flg}" = 'Yes' ] && [ "${map_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" = 'Yes' ] && [ "${vrt_usr_flg}" != 'Yes' ]; then
    flg_grd_only='Yes'
fi # !flg_grd_only
if [ "${map_mk}" = 'Yes' ] || [ "${map_usr_flg}" = 'Yes' ]; then
    flg_hrz='Yes'
fi # !map_mk, !map_usr_flg
if [ "${flg_hrz}" != 'Yes' ]; then
    # Turn-off dimension permutation if file will not be horizontally regridded
    pdq_opt=''
    pdq_flg='No'
fi # !flg_hrz

# Generate destination grid, if necessary, once (only) before loop over input files
# Block 1: Destination grid
# Generate destination grid at most one-time (unlike source grid)
# Eventually we will allow destination grid to be provided as grid-file, map-file, or data-file without a switch
# Currently we require user to know (and specify) means by which destination grid is provided
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    if [ ${fl_nbr} -eq 0 ]; then
	printf "Map/grid-only run: no input data detected therefore will exit after generating map and/or grid\n"
    fi # !fl_nbr
    if [ -n "${pdq_opt}" ] && [ "${pdq_flg}" = 'Yes' ]; then 
	printf "Input data shaped in native \"${prc_typ}\"-order, will permute with \"ncpdq ${pdq_opt}\" prior to horizontal regridding\n"
    fi # !pdq_opt
    if [ "${d2f_flg}" = 'Yes' ]; then
	printf "Will convert all non-coordinate double precision input fields to single precision with \"ncpdq ${d2f_opt}\"\n"
    fi # !d2f_flg
    if [ "${prc_mpas}" = 'Yes' ]; then
	printf "MPAS input specified: will automatically renormalize (with --rnr=0.0) horizontally regridded fields\n"
	if [ "${clm_flg}" = 'No' ]; then
 	    printf "MPAS input specified: will automatically annotate NC_FLOAT and NC_DOUBLE variables with _FillValue = ${mss_val} prior to horizontal regridding\n"
	fi # !clm_flg
	if [ "${dpt_flg}" = 'Yes' ]; then
 	    printf "MPAS input specified: will add depth coordinate to all 3D variables prior to horizontal regridding\n"
	fi # !dpt_flg
    fi # !mpas
    if [ "${prc_sgs}" = 'Yes' ]; then 
	printf "Input assumed to contain sub-gridscale (SGS, aka \"fractional area\") data: Intensive values valid in gridcell for spatiotemporal fraction specified by \"${sgs_frc}\" variable, not for entire gridcell area and/or time-interval duration (except where ${sgs_frc} = 1.0). Will regrid ${sgs_frc}, and then normalize subsequent regridding to conserve ${sgs_frc}*gridcell_area*field_value (not gridcell_area*field_value). If re-normalization is also requested (e.g., with --rnr_thr option, or with --preserve=mean), then these values will be renormalized by ${sgs_frc} and will not be conservative.\n"
	if [ ${fl_nbr} -eq 0 ]; then
	    printf "${spt_nm}: ERROR Sub-gridscale handling currently requires at least one data file (for the surface fractions of each gridcell)\n"
	    echo "${spt_nm}: HINT Supply a data file with \"-i fl_in\""
	    exit 1
	fi # !fl_nbr
    fi # !prc_sgs
fi # !vrb_lvl
if [ "${flg_hrz}" = 'Yes' ]; then
    if [ "${map_mk}" != 'Yes' ] && [ "${map_usr_flg}" = 'Yes' ]; then 
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    printf "Source and destination grids will both be read from supplied map-file\n"
	fi # !vrb_lvl
    else # !map_usr_flg
	fl_idx=0 # [idx] Current file index
	if [ "${dst_usr_flg}" = 'Yes' ]; then 
	    # Block 1 Loop 1: Generate, check, and store (but do not yet execute) commands
	    # Infer destination grid-file from data file
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "Destination grid will be inferred from destination data-file\n"
	    fi # !vrb_lvl
	    cmd_dst[${fl_idx}]="ncks -O ${nco_opt} --rgr infer --rgr hnt_dst=\"${hnt_dst_fl}\" ${nco_dgn_area} ${nco_msk_dst} ${nco_var_rgr} ${nco_ugrid_fl} --rgr scrip=\"${grd_dst}\" \"${dst_fl}\" \"${tmp_out_fl}\""
	else # !dst_usr_flg
	    if [ "${grd_dst_usr_flg}" = 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ]; then 
		if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		    printf "Destination grid supplied by user\n"
		fi # !vrb_lvl
	    fi # !grd_dst_usr_flg
	    if [ "${grd_dst_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ]; then 
		printf "${spt_nm}: WARNING No destination grid specified with -g, template/inferral file specified with -d, or grid string specified with -G\n"
	    fi # !grd_dst_usr_flg
	    if [ "${grd_sng_usr_flg}" = 'Yes' ]; then
		# 20180903 Must quote grd_sng otherwise whitespace and shell redirection characters (e.g., in ttl argument) will confuse interpreter
		cmd_dst[${fl_idx}]="ncks -O --dmm_in_mk ${nco_opt} --rgr scrip=\"${grd_dst}\" ${nco_skl_fl} --rgr '${grd_sng}' \"${dmm_fl}\" \"${tmp_out_fl}\""
		if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		    if [ "${grd_dst_usr_flg}" = 'Yes' ]; then
			printf "Destination grid will be generated in SCRIP format from NCO grid-formula ${grd_sng} and stored in ${grd_dst}\n"
		    else
			printf "Destination grid will be generated in SCRIP format from NCO grid-formula ${grd_sng} and stored in a temporary, internal location\n"
		    fi # !grd_sng_usr_flg
		fi # !vrb_lvl
	    fi # !grd_sng_usr_flg
	fi # !dst_usr_flg
	if [ "${dst_usr_flg}" = 'Yes' ] || [ "${grd_sng_usr_flg}" = 'Yes' ]; then 
	    # Block 1 Loop 2: Execute and/or echo commands
	    if [ ${wgt_typ} != 'cdo' ]; then
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_dst[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_dst[${fl_idx}]}
		    if [ "$?" -ne 0 ]; then
			if [ "${grd_sng_usr_flg}" = 'Yes' ]; then
			    printf "${spt_nm}: ERROR Failed to generate grid from user-supplied grid-string. Debug this:\n${cmd_dst[${fl_idx}]}\n"
			else # !grd_sng_usr_flg
			    printf "${spt_nm}: ERROR Failed to infer destination grid. Debug this:\n${cmd_dst[${fl_idx}]}\n"
			fi # !grd_sng_usr_flg
			exit 1
		    fi # !err
		    if [ "${grd_sng_usr_flg}" = 'Yes' ]; then 
			/bin/rm -f ${tmp_out_fl}
		    fi # !grd_sng_usr_flg
		fi # !dbg
	    fi # !cdo
	fi # !dst_usr_flg || grd_dst_usr_flg
	if [ ${vrb_lvl} -ge ${vrb_3} ] && [ ${flg_grd_only} != 'Yes' ]; then
	    printf "Weight-generation type: ${wgt_typ}\n"
	    printf "Algorithm selected to generate weights in map-file is: ${alg_opt}\n"
	    printf "Will generate mapping weights and map-file with \'${wgt_cmd}\'\n"
	    [[ -n "${map_nfo_sng}" ]] && echo "${map_nfo_sng}"
	fi # !vrb_lvl
	if [ ${flg_grd_only} != 'Yes' ]; then
	    command -v ${wgt_exe} 2>&1 > /dev/null || { printf "${spt_nm}: ERROR cannot find weight-generation command executable ${wgt_exe}. Please install the executable, and/or change your PATH to find it.\n${spt_nm}: HINT The Conda 'nco' package automagically installs the 'esmf' package to provide ESMF_RegridWeightGen and the 'tempest-remap' package to install TempestRemap executables such as 'GenerateOfflineMap'. One can obtain the MOAB-Tempest executables like 'mbtempest' via the Conda 'moab' package.\n"; exit 1; }
	fi # !flg_grd_only
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    if [ ${fl_nbr} -ge 2 ]; then 
		if [ "${mlt_map_flg}" = 'Yes' ]; then 
		    printf "Input files assumed to use unique input grids\nOne source grid-file will be inferred and one map-file generated per input file\n"
		else # !mlt_map_flg
		    printf "Input files assumed to use same input grid\nOnly one source grid-file and one map-file will be generated\n"
		fi # !mlt_map_flg
	    fi # !fl_nbr
	fi # !vrb_lvl
    fi # !map_usr
fi # !flg_hrz

if [ "${prc_typ}" = 'rrg' ]; then 
    fl_idx=0

    if [ -z "${rnm_sng}" ]; then 
	# Discern rename string from input file, assume dimension is 'ncol', strip whitespace
	rnm_sng=`ncks -m ${fl_in[${fl_idx}]} | cut -d ':' -f 1 | cut -d '=' -s -f 1 | grep ncol | sed 's/ncol//' | sed -e 's/^ *//' -e 's/ *$//'`
	rgn_nbr=`echo ${rnm_sng} | wc -l`
	if [ "${rgn_nbr}" -ne 1 ]; then
	    echo "ERROR: Inferred regional regridding suffix '${rnm_sng}' indicates multiple regions present in input file. ncremap only works on one region at a time."
	    echo "HINT: Provide a single region string as the argument to the --rrg_rnm_sng option"
	    exit 1
	fi # !rgn_nbr
	echo "${spt_nm}: INFO Parsed input file dimension list to obtain regional suffix string '${rnm_sng}'"
    fi # !rnm_sng
    if [ -n "${rnm_sng}" ]; then 
	if [ -n "${bb_wesn}" ]; then 
	    echo "${spt_nm}: INFO Will use explicitly specified comma-separated rectangular WESN bounding box string ${bb_wesn} instead of parsing string suffix ${rnm_sng}."
	else # !bb_wesn
	    rnm_rx='^_(.*)_to_(.*)_(.*)_to_(.*)$'
	    if [[ "${rnm_sng}" =~ ${rnm_rx} ]]; then
		lon1=${BASH_REMATCH[1]%?}
		lon2=${BASH_REMATCH[2]%?}
		if [ "${BASH_REMATCH[1]: -1}" = 'w' ]; then
		    let lon1=360-${lon1}
		fi # !w
		if [ "${BASH_REMATCH[2]: -1}" = 'w' ]; then
		    let lon2=360-${lon2}
		fi # !w
		if [ ${lon1} -lt ${lon2} ]; then
		    lon_min=${lon1}
		    lon_max=${lon2}
		else
		    # 20210526 Until today we swapped the W,E bounds incorrectly
		    # if wrapped nco_aux_prs() adds 360 degrees to lon_max to ensure lon_min < lon_max
		    lon_min=${lon2}
		    lon_max=${lon1}
		fi # !lon1
		lat1=${BASH_REMATCH[3]%?}
		lat2=${BASH_REMATCH[4]%?}
		if [ "${BASH_REMATCH[3]: -1}" = 's' ]; then
		    let lat1=-${lat1}
		fi # !w
		if [ "${BASH_REMATCH[4]: -1}" = 's' ]; then
		    let lat2=-${lat2}
		fi # !w
		if [ ${lat1} -lt ${lat2} ]; then
		    lat_min=${lat1}
		    lat_max=${lat2}
		else
		    lat_min=${lat2}
		    lat_max=${lat1}
		fi # !lat1
	    else # !rnm_sng
		echo "ERROR: Regional regridding suffix string '${rnm_sng}' does not match regular expression '${rnm_rx}'"
		echo "HINT: Regional regridding suffix string must have form like '_128e_to_134e_9s_to_16s' or '_20w_to_20e_10s_to_10n'"
		exit 1
	    fi # !rnm_sng
	    bb_wesn="${lon_min},${lon_max},${lat_min},${lat_max}"
	    echo "${spt_nm}: INFO Parsed suffix string ${rnm_sng} to obtain comma-separated rectangular WESN bounding box string ${bb_wesn}"
	fi # !bb_wesn
    else
	echo "${spt_nm}: ERROR Regional regridding requires string suffix appended to variables in regional data file to be specified with --rrg_rnm_sng argument"
	exit 1
    fi # !rnm_sng

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Input assumed to be EAM/CAM-SE format regional data to regrid (aka RRG). RRG data are usually produced by explicitly requesting (sometimes multiple) regions from EAM/CAM-SE models with the \"finclNlonlat\" namelist variable. Will infer SCRIP-format regional source grid by cutting vertice information (originally from global dual-grid file ${grd_glb}) from rectangular WESN bounding box \"${bb_wesn}\" of identity-remapped (and thus vertice-annotated) copy of global data file ${dat_glb}. Will then create single map-file to regrid copy of requested fields with \"${rnm_sng}\" removed from dimension and variable names.\n"
    fi # !vrb_lvl

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "RRG: Identity-remap global data file from/to dual-grid to annotate it with vertices...\n"
    fi # !vrb_lvl
    cmd_nnt[${fl_idx}]="ncremap --vrb=0 -a esmfbilin -s \"${grd_glb}\" -g \"${grd_glb}\" \"${dat_glb}\" \"${nnt_fl}\""
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_nnt[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_nnt[${fl_idx}]}
	if [ "$?" -ne 0 ]; then
	    printf "${spt_nm}: ERROR Failed to identity-remap to annotate global data file. Debug this:\n${cmd_nnt[${fl_idx}]}\n"
	    exit 1
	fi # !err
    fi # !dbg

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "RRG: Subset coordinates to rectangular WESN regional bounding box ${bb_wesn}...\n"
    fi # !vrb_lvl
    cmd_sbs[${fl_idx}]="ncks -O -v lat,lon -X ${bb_wesn} \"${nnt_fl}\" \"${rgn_fl}\""
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_sbs[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_sbs[${fl_idx}]}
	if [ "$?" -ne 0 ]; then
	    printf "${spt_nm}: ERROR Failed to subset and hyperslab coordinates into regional file. Debug this:\n${cmd_sbs[${fl_idx}]}\n"
	    exit 1
	fi # !err
    fi # !dbg

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "RRG: Infer source grid from subsetted, annotated, regional coordinate file...\n"
    fi # !vrb_lvl
    cmd_nfr[${fl_idx}]="ncks -O ${nco_opt} --rgr infer --rgr hnt_src=\"${hnt_src_fl}\" ${nco_dgn_area} ${nco_msk_src} ${nco_var_rgr} --rgr scrip=\"${grd_src}\" \"${rgn_fl}\" \"${tmp_out_fl}\""
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_nfr[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_nfr[${fl_idx}]}
	if [ "$?" -ne 0 ]; then
	    printf "${spt_nm}: ERROR Failed to infer source grid from subsetted, annotated, regional coordinate file. Debug this:\n${cmd_nfr[${fl_idx}]}\n"
	    exit 1
	fi # !err
    fi # !dbg
fi # !rrg

# 20211102 Pre-process destination grid prior to weight-generation by mbtempest
# NB: Unlike source grid, destination grid never changes in file-loop, so pre-process here
if [ "${map_mk}" = 'Yes' ]; then 
    if [ "${wgt_typ}" = 'mbtempest' ]; then
	# 20210827 Pre-process input .nc, .g, and .h5m files to partitioned .h5m files
	if [[ ${grd_dst} == *.g ]] || [[ ${grd_dst} == *.exo ]] || [[ ${grd_dst} == *".nc"* ]]; then
	    [[ ${grd_dst} == *.g ]] && grd_dst_h5m_tmp="${grd_dst/.g/.h5m}"
	    [[ ${grd_dst} == *.exo ]] && grd_dst_h5m_tmp="${grd_dst/.exo/.h5m}"
	    [[ ${grd_dst} == *".nc"* ]] && grd_dst_h5m_tmp="${grd_dst/.nc/.h5m}"
	    cmd_e2m[${fl_idx}]="${cmd_cnv_mbt} ${cnv_opt_dst} ${cnv_opt_e2m} \"${grd_dst}\" \"${grd_dst_h5m_tmp}\"${devnull}"
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_e2m[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_e2m[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${grd_src_h5m} ]; then
		    printf "${spt_nm}: ERROR Failed to convert destination grid to MOAB H5M format. Debug this:\n${cmd_e2m[${fl_idx}]}\n"
		    printf "${spt_nm}: HINT ${cnv_exe_mbt} can fail for a number of reasons including 1) fxm ...\n"
		    exit 1
		fi # !err
	    fi # !dbg
	    grd_dst=${grd_dst_h5m_tmp}
	fi # !grd_dst
	if [[ ${grd_dst} == *.h5m ]] && [[ ${grd_dst} != *p.h5m ]]; then
	    grd_dst_prt_tmp="${grd_dst/.h5m/_${prt_nbr}p.h5m}"
	    if [ ${prt_alg} = 'zoltan' ]; then
		# 20210829: NB: Compy installation only has Zoltan not METIS
		cmd_prt[${fl_idx}]="${cmd_prt_mbt} ${prt_nbr} --zoltan RCB -i 1.002 --recompute_rcb_box --scale_sphere --project_on_sphere 2 ${prt_opt_dst} \"${grd_dst}\" \"${grd_dst_prt_tmp}\"${devnull}"
	    else # !prt_alg
		# 20210829: moab=5.3.0=*nompi_tempest* only supplies METIS, not Zoltan, lacks --scale_sphere completely, and must use -p instead of --project_on_sphere
		cmd_prt[${fl_idx}]="${cmd_prt_mbt} ${prt_nbr} --metis ML_RB -i 1.005 -p 2 ${prt_opt_dst} \"${grd_dst}\" \"${grd_dst_prt_tmp}\"${devnull}"
	    fi # !HOSTNAME
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_prt[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_prt[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${grd_dst_prt_tmp} ]; then
		    printf "${spt_nm}: ERROR Failed to partition MOAB destination grid. Debug this:\n${cmd_prt[${fl_idx}]}\n"
		    printf "${spt_nm}: HINT ${prt_exe_mbt} can fail for a number of reasons including 1) fxm ...\n"
		    exit 1
		fi # !err
	    fi # !dbg
	    grd_dst=${grd_dst_prt_tmp}
	fi # !grd_dst
    fi # !mbtempest
fi # !map_mk
    
# If user provides source gridfile, or it was inferred in RRG or SGS modes, assume it applies to every input file
# In that case, no need to infer source gridfiles within file loop
# Generate map-file once outside of file loop, and re-use it for every input file
if [ "${grd_src_usr_flg}" = 'Yes' ] || [ "${prc_typ}" = 'rrg' ]; then
    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Source grid supplied by user (or derived from RRG procedure) as ${grd_src}\n"
    fi # !vrb_lvl
    fl_idx=0
    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
	printf "Grid(src): ${grd_src}\n"
	printf "Grid(dst): ${grd_dst}\n"
    fi # !vrb_lvl
    if [ "${wgt_typ}" = 'cdo' ]; then 
	cmd_map[${fl_idx}]="${wgt_cmd} -gencon,\"${dst_fl}\" \"${in_fl}\" \"${map_fl}\"${devnull}"
	#cmd_map[${fl_idx}]="${wgt_cmd} -gencon,\"${grd_dst}\" \"${grd_src}\" \"${map_fl}\"${devnull}"
    elif [ "${wgt_typ}" = 'esmf' ]; then 
	rgn_opt=''
	if [ -n "${hnt_src}" ]; then
	    rgn_opt="${rgn_opt} ${hnt_src}"
	elif [ -f "${hnt_src_fl}" ]; then
	    rgn_opt="${rgn_opt} `cat ${hnt_src_fl}`"
	fi # !hnt_src_fl
	if [ -n "${hnt_dst}" ]; then
	    rgn_opt="${rgn_opt} ${hnt_dst}"
	elif [ -f "${hnt_dst_fl}" ]; then
	    rgn_opt="${rgn_opt} `cat ${hnt_dst_fl}`"
	fi # !hnt_dst_fl
	cmd_map[${fl_idx}]="${wgt_cmd} -s \"${grd_src}\" -d \"${grd_dst}\" -w \"${map_fl}\" --method ${alg_opt} ${wgt_opt} ${rgn_opt}${devnull}"
    elif [ "${wgt_typ}" = 'nco' ]; then 
	cmd_map[${fl_idx}]="${wgt_cmd} ${wgt_opt} --thr_nbr=${thr_nbr} ${nco_opt} --grd_src=\"${grd_src}\" --grd_dst=\"${grd_dst}\" --map_fl=\"${map_fl}\" ${msh_opt} ${rgr_opt} \"${dmm_fl}\" \"${tmp_out_fl}\"${devnull}"
    elif [ "${wgt_typ}" = 'mbtempest' ]; then 
	# 20210827 Pre-process input .nc, .g, and .h5m files to partitioned .h5m files
	if [[ ${grd_src} == *.g ]] || [[ ${grd_src} == *.exo ]] || [[ ${grd_src} == *".nc"* ]]; then
	    [[ ${grd_src} == *.g ]] && grd_src_h5m_tmp="${grd_src/.g/.h5m}"
	    [[ ${grd_src} == *.exo ]] && grd_src_h5m_tmp="${grd_src/.exo/.h5m}"
	    [[ ${grd_src} == *".nc"* ]] && grd_src_h5m_tmp="${grd_src/.nc/.h5m}"
	    cmd_e2m[${fl_idx}]="${cmd_cnv_mbt} ${cnv_opt_src} ${cnv_opt_e2m} \"${grd_src}\" \"${grd_src_h5m_tmp}\"${devnull}"
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_e2m[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_e2m[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${grd_src_h5m_tmp} ]; then
		    printf "${spt_nm}: ERROR Failed to convert source grid to MOAB H5M format. Debug this:\n${cmd_e2m[${fl_idx}]}\n"
		    printf "${spt_nm}: HINT ${cnv_exe_mbt} can fail for a number of reasons including 1) Environment paths must resolve the correct version of libTempestRemap. 2) mbconvert must support the -B option. Some versions of mbconvert do not. 3) mbconvert must support the PARALLEL option. Serial versions of mbconvert do not.\n"
		    printf "${spt_nm}: HINT a simple way to install a MOAB compatible with ncremap is install them both into their own environment, e.g., \n\tconda create -n moab_nco -c conda-forge moab=5.3.0=*mpich_tempest* nco\n"
		    exit 1
		fi # !err
	    fi # !dbg
	    grd_src=${grd_src_h5m_tmp}
	fi # !grd_src
	if [[ ${grd_src} == *.h5m ]] && [[ ${grd_src} != *p.h5m ]]; then
	    grd_src_prt_tmp="${grd_src/.h5m/_${prt_nbr}p.h5m}"
	    if [ ${prt_alg} = 'zoltan' ]; then
		# 20210829: NB: Compy installation only has Zoltan not METIS
		cmd_prt[${fl_idx}]="${cmd_prt_mbt} ${prt_nbr} --zoltan RCB -i 1.002 --recompute_rcb_box --project_on_sphere 2 ${prt_opt_src} \"${grd_src}\" \"${grd_src_prt_tmp}\"${devnull}"
	    else # !prt_alg
		# 20210829: moab=5.3.0=*nompi_tempest* only supplies METIS, not Zoltan, lacks --scale_sphere completely, and must use -p instead of --project_on_sphere
		cmd_prt[${fl_idx}]="${cmd_prt_mbt} ${prt_nbr} --metis ML_RB -i 1.005 -p 2 ${prt_opt_src} \"${grd_src}\" \"${grd_src_prt_tmp}\"${devnull}"
	    fi # !HOSTNAME
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_prt[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_prt[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${grd_src_prt_tmp} ]; then
		    printf "${spt_nm}: ERROR Failed to partition MOAB version of source grid. Debug this:\n${cmd_prt[${fl_idx}]}\n"
		    printf "${spt_nm}: HINT ${prt_exe_mbt} can fail for a number of reasons including 1) fxm ...\n"
		    exit 1
		fi # !err
	    fi # !dbg
	    grd_src=${grd_src_prt_tmp}
	fi # !grd_src
	if [ ${prt_alg} = 'zoltan' ]; then
	    cmd_map[${fl_idx}]="${wgt_cmd} --type ${mbt_typ_map} --weights --load \"${grd_src}\" --load \"${grd_dst}\" ${wgt_opt} --file \"${map_fl}\"${devnull}"
	else # !prt_alg
	    cmd_map[${fl_idx}]="${wgt_cmd} --type ${mbt_typ_map} --weights --load \"${grd_src}\" --load \"${grd_dst}\" ${wgt_opt} --file \"${map_fl}\"${devnull}"
	fi # !prt_alg
    elif [ "${wgt_typ}" = 'tempest' ]; then 
    	cmd_msh[${fl_idx}]="${cmd_msh_tps} ${msh_opt_tps} --a \"${grd_src}\" --b \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
	if [ "${a2o_flg}" = 'Yes' ]; then 
	   cmd_msh[${fl_idx}]="${cmd_msh_tps} ${msh_opt_tps} --b \"${grd_src}\" --a \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
	fi # !a2o_flg
	cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_src}\" --out_mesh \"${grd_dst}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_fl}\" ${wgt_opt}${devnull}"
	if [ "${trn_map}" = 'Yes' ]; then 
	    # NB: Generate mono map for opposite direction regridding (i.e., reverse switches and grids), then transpose
	    cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_dst}\" --out_mesh \"${grd_src}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_trn_fl}\" ${wgt_opt}${devnull}"
	    cmd_trn[${fl_idx}]="GenerateTransposeMap --in \"${map_trn_fl}\" --out \"${map_fl}\"${devnull}"
	fi # !trn_map
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_msh[${fl_idx}]}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_msh[${fl_idx}]}
	    if [ "$?" -ne 0 ] || [ ! -f ${msh_fl} ]; then
		printf "${spt_nm}: ERROR Failed to generate intersection mesh-file. Debug this:\n${cmd_msh[${fl_idx}]}\n"
		printf "${spt_nm}: HINT ${msh_exe_tps} can fail for a number of reasons including 1) It requires that grids of unequal area be given as arguments in the order smaller first, larger second. ncremap supplies the grid arguments in the order source first, destination second unless explicitly told otherwise. A source grid that is a superset of the destination would violate the ${msh_exe_tps} rule. The solution is to add the \"--a2o\" switch (documented at http://nco.sf.net/nco.html#a2o) that tells ncremap to swap the grid argument order. 2) It requires that SCRIP files strictly adhere to SCRIP conventions, including that \"grid_imask\" be of integer type not floating-point type. Unfortunately some malformed SCRIP files violate this convention. The workaround can be as simple as \"ncap2 -s 'grid_imask=int(grid_imask)' grid_in.nc grid_out.nc\"\n"
		exit 1
	    fi # !err
	fi # !dbg
    fi # !wgt_typ
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_map[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_map[${fl_idx}]}
	if [ "$?" -ne 0 ] || [ ! -f ${map_rsl_fl} ]; then
	    printf "${spt_nm}: ERROR Failed to generate map-file. Debug this:\n${cmd_map[${fl_idx}]}\n"
	    if [ "${wgt_typ}" = 'esmf' ]; then 
		printf "${spt_nm}: HINT When ESMF fails to generate map-files, it often puts additional debugging information in the file named PET0.RegridWeightGen.Log in the invocation directory (${drc_pwd})\n"
	    fi # !esmf
	    exit 1
	fi # !err
    fi # !dbg
    # 20181116: GenerateTransposeMap does not propagate global attributes from input map
    # Moreover, it does not generate any metadata of its own except "Title"
    # Hence monotr maps are naked of usual Tempest map metadata
    if [ "${trn_map}" = 'Yes' ]; then 
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_trn[${fl_idx}]}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_trn[${fl_idx}]}
	    if [ "$?" -ne 0 ] || [ ! -f ${map_fl} ]; then
		printf "${spt_nm}: ERROR Failed to transpose map-file. Debug this:\n${cmd_trn[${fl_idx}]}\n"
		exit 1
	    fi # !err
	fi # !dbg
    fi # !trn_map
    if [ "${map_usr_flg}" = 'Yes' ]; then
	hst_att="`date`: ${cmd_ln}; ${cmd_map[${fl_idx}]}"
	if [ "${wgt_typ}" = 'tempest' ]; then 
	    hst_att="`date`: ${cmd_ln}; ${cmd_msh[${fl_idx}]}; ${cmd_map[${fl_idx}]}"
	    if [ "${trn_map}" = 'Yes' ]; then 
		hst_att="${hst_att}; ${cmd_trn[${fl_idx}]}"
	    fi # !trn_map
	fi # !tempest
	cmd_att[${fl_idx}]="ncatted -O ${gaa_sng} --gaa history='${hst_att}' ${gad_sng} \"${map_fl}\""
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_att[${fl_idx}]}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_att[${fl_idx}]}
	    if [ "$?" -ne 0 ] || [ ! -f ${map_fl} ]; then
		printf "${spt_nm}: ERROR Failed to annotate map-file. Debug this:\n${cmd_att[${fl_idx}]}\n"
		exit 1
	    fi # !err
	fi # !dbg
    fi # !map_usr_flg
    # Set map_mk to something besides 'Yes' to avoid re-generating map within file loop
    map_mk='Already made map once. Never again!'
fi # !grd_src_usr_flg

# Begin loop over input files
let bch_nbr=$((fl_nbr / job_nbr))
let bch_flg=$((fl_nbr % job_nbr))
if [ ${fl_nbr} -gt 0 ] && [ ${bch_nbr} -eq 0 ]; then
    let bch_nbr=$((bch_nbr+1))
elif [ ${bch_flg} -ne 0 ]; then
    let bch_nbr=$((bch_nbr+1))
fi # !bch_flg
let bch_nbrm1=$((bch_nbr-1))
for ((bch_idx=0;bch_idx<bch_nbr;bch_idx++)); do
    # fl_idx is 0-based, bch_idx is 0-based
    let fl_idx_srt=$((bch_idx * job_nbr))
    let fl_idx_end=$((fl_idx_srt + job_nbr - 1))
    if [ ${bch_idx} -eq ${bch_nbrm1} ] && [ ${bch_flg} -ne 0 ]; then
	let fl_idx_srt=$((bch_idx * job_nbr))
	let fl_idx_end=$((fl_nbr - 1))
    fi # !bch_flg
    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	in_fl=${fl_in[${fl_idx}]}
	if [ "$(basename "${in_fl}")" = "${in_fl}" ]; then
	    in_fl="${drc_pwd}/${in_fl}"
	fi # !basename
	idx_prn=`printf "%02d" ${fl_idx}`
	if [ ${vrb_lvl} -ge ${vrb_1} ]; then
	    printf "Input #${idx_prn}: ${in_fl}\n"
	fi # !vrb_lvl
	if [ "${out_usr_flg}" = 'Yes' ]; then 
	    if [ ${fl_nbr} -ge 2 ]; then 
		echo "ERROR: Single output filename specified with -o for multiple input files"
		echo "HINT: For multiple input files use -O option to specify output directory and do not use -o or second positional option. Output files will have same name as input files, but will be in different directory."
		exit 1
	    fi # !fl_nbr
	    if [ -n "${drc_usr}" ]; then
		out_fl="${drc_out}/${out_fl}"
	    fi # !drc_usr
	else # !out_usr_flg
	    out_fl="${drc_out}/$(basename "${in_fl}")"
	fi # !out_fl
	# Test whether input and output filenames point to the same file (i.e., same device and inode numbers)
	if [ "${in_fl}" -ef "${out_fl}" ]; then
	# if [ "${in_fl}" = "${out_fl}" ]; then
	    echo "ERROR: Input file = ${in_fl} and Output file = ${out_fl} point to the same file, i.e., point to the same device and inode numbers"
	    echo "HINT: To prevent inadvertent data loss/corruption, ${spt_nm} insists that the Input and Output files be distinct. Retry command after renaming the Output file to a distinct location."
	    exit 1
	fi # !basename
	fl_in[${fl_idx}]=${in_fl}
	fl_out[${fl_idx}]=${out_fl}

	# Temporary files that need fl_idx granularity
	if [ -n "${unq_sfx}" ]; then
	    unq_sfx_grn="${unq_sfx}.flidx${fl_idx}"
	fi # !unq_sfx
	att_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_att.nc${unq_sfx_grn}" # [sng] Missing value workflow (MPAS) default
	d2f_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_d2f.nc${unq_sfx_grn}" # [sng] File with doubles converted to float
	dpt_tmp_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_dpt.nc${unq_sfx_grn}" # [sng] File with depth coordinate added
	pdq_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_pdq.nc${unq_sfx_grn}" # [sng] Permuted/Unpacked data default (AIRS, HIRDLS, MLS, MOD04, MPAS)
	rnm_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_rnm.nc${unq_sfx_grn}" # [sng] Renamed regional (RRG) default

	# Generate new map unless map-file was supplied or already-generated
	# Multiple maps can be generated only if mlt_map_flg=Yes (temporarily borken 20190920)
	# NB: RRG infers source grid outside file loop, and forbids multiple source grids
	# RRG produces map before file loop, and will not make maps inside file loop
	if [ "${map_mk}" = 'Yes' ] && [ "${fl_idx}" -eq 0 ]; then
	    
	    # Block 1: Special cases
	    if [ "${prc_typ}" = 'hirdls' ] || [ "${prc_typ}" = 'mls' ]; then
		# Pre-process zonal input files so grid inferral works
		# 20160214: fix record variable to work around ncpdq problem
		cmd_znl[${fl_idx}]="ncecat -O -u lon ${nco_opt} ${nco_var_lst} \"${in_fl}\" \"${in_fl}\" \"${in_fl}\" \"${in_fl}\" \"${znl_fl/znl/znl1}\";ncap2 -O ${nco_opt} -s 'lon[\$lon]={0.0,90.0,180.0,270.0}' \"${znl_fl/znl/znl1}\" \"${znl_fl/znl/znl2}\""
		in_fl="${znl_fl/znl/znl2}"
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_znl[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_znl[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f "${znl_fl/znl/znl2}" ]; then
			printf "${spt_nm}: ERROR Failed to generate lat-lon file from zonal file. Debug this:\n${cmd_znl[${fl_idx}]}\n"
			exit 1
		    fi # !err
		fi # !dbg
	    fi # !znl
	    
	    # Block 2: Source grid
	    # Block 2 Loop 1: Source gridfile command
	    if [ ! -f "${in_fl}" ] && [ ! -L "${in_fl}" ]; then
		echo "${spt_nm}: ERROR Unable to find input file ${in_fl}"
		echo "HINT: All files implied to exist must be in the directory specified by their filename or in ${drc_in} before ${spt_nm} will proceed"
		exit 1
	    fi # ! -f

	    if [ "${wgt_typ}" != 'cdo' ]; then 
		# Infer source grid-file from input data file
		cmd_src[${fl_idx}]="ncks -O ${nco_opt} --rgr infer --rgr hnt_src=\"${hnt_src_fl}\" ${nco_dgn_area} ${nco_msk_src} ${nco_ugrid_fl} ${nco_var_rgr} --rgr scrip=\"${grd_src}\" \"${in_fl}\" \"${tmp_out_fl}\""
	
		# Block 2 Loop 2: Execute and/or echo commands
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_src[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_src[${fl_idx}]}
		    if [ "$?" -ne 0 ]; then
			printf "${spt_nm}: ERROR Failed to infer source grid. Debug this:\n${cmd_src[${fl_idx}]}\n"
			exit 1
		    fi # !err
		fi # !dbg

		# If source grid was just inferred in preceding block, convert and partition it
		# Duplicate code of mbtempest source grid blocks above
		if [ "${wgt_typ}" = 'mbtempest' ]; then 
		    # 20210827 Pre-process input .nc, .g, and .h5m files to partitioned .h5m files
		    if [[ ${grd_src} == *.g ]] || [[ ${grd_src} == *.exo ]] || [[ ${grd_src} == *".nc"* ]]; then
			[[ ${grd_src} == *.g ]] && grd_src_h5m_tmp="${grd_src/.g/.h5m}"
			[[ ${grd_src} == *.exo ]] && grd_src_h5m_tmp="${grd_src/.exo/.h5m}"
			[[ ${grd_src} == *".nc"* ]] && grd_src_h5m_tmp="${grd_src/.nc/.h5m}"
			cmd_e2m[${fl_idx}]="${cmd_cnv_mbt} ${cnv_opt_src} ${cnv_opt_e2m} \"${grd_src}\" \"${grd_src_h5m_tmp}\"${devnull}"
			if [ ${dbg_lvl} -ge 1 ]; then
			    echo ${cmd_e2m[${fl_idx}]}
			fi # !dbg
			if [ ${dbg_lvl} -ne 2 ]; then
			    eval ${cmd_e2m[${fl_idx}]}
			    if [ "$?" -ne 0 ] || [ ! -f ${grd_src_h5m_tmp} ]; then
				printf "${spt_nm}: ERROR Failed to convert source grid to MOAB H5M format. Debug this:\n${cmd_e2m[${fl_idx}]}\n"
				printf "${spt_nm}: HINT ${cnv_exe_mbt} can fail for a number of reasons including 1) Environment paths must resolve the correct version of libTempestRemap. 2) mbconvert must support the -B option. Some versions of mbconvert do not. 3) mbconvert must support the PARALLEL option. Serial versions of mbconvert do not.\n"
				printf "${spt_nm}: HINT a simple way to install a MOAB compatible with ncremap is install them both into their own environment, e.g., \n\tconda create -n moab_nco -c conda-forge moab=5.3.0=*mpich_tempest* nco\n"
				exit 1
			    fi # !err
			fi # !dbg
			grd_src=${grd_src_h5m_tmp}
		    fi # !grd_src
		    if [[ ${grd_src} == *.h5m ]] && [[ ${grd_src} != *p.h5m ]]; then
			grd_src_prt_tmp="${grd_src/.h5m/_${prt_nbr}p.h5m}"
			if [ ${prt_alg} = 'zoltan' ]; then
			    # 20210829: NB: Compy installation only has Zoltan not METIS
			    cmd_prt[${fl_idx}]="${cmd_prt_mbt} ${prt_nbr} --zoltan RCB -i 1.002 --recompute_rcb_box --project_on_sphere 2 ${prt_opt_src} \"${grd_src}\" \"${grd_src_prt_tmp}\"${devnull}"
			else # !prt_alg
			    # 20210829: moab=5.3.0=*nompi_tempest* only supplies METIS, not Zoltan, lacks --scale_sphere completely, and must use -p instead of --project_on_sphere
			    cmd_prt[${fl_idx}]="${cmd_prt_mbt} ${prt_nbr} --metis ML_RB -i 1.005 -p 2 ${prt_opt_src} \"${grd_src}\" \"${grd_src_prt_tmp}\"${devnull}"
			fi # !HOSTNAME
			if [ ${dbg_lvl} -ge 1 ]; then
			    echo ${cmd_prt[${fl_idx}]}
			fi # !dbg
			if [ ${dbg_lvl} -ne 2 ]; then
			    eval ${cmd_prt[${fl_idx}]}
			    if [ "$?" -ne 0 ] || [ ! -f ${grd_src_prt_tmp} ]; then
				printf "${spt_nm}: ERROR Failed to partition MOAB version of source grid. Debug this:\n${cmd_prt[${fl_idx}]}\n"
				printf "${spt_nm}: HINT ${prt_exe_mbt} can fail for a number of reasons including 1) fxm ...\n"
				exit 1
			    fi # !err
			fi # !dbg
			grd_src=${grd_src_prt_tmp}
		    fi # !grd_src
		fi # !mbtempest
	    fi # !cdo
	    
	    # Block 3: Source->destination maps
	    # Block 3 Loop 1: Map-file commands
	    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		printf "Grid(src): ${grd_src}\n"
		printf "Grid(dst): ${grd_dst}\n"
	    fi # !vrb_lvl
	    if [ "${wgt_typ}" = 'cdo' ]; then 
		cmd_map[${fl_idx}]="${wgt_cmd} -gencon,\"${dst_fl}\" \"${in_fl}\" \"${map_fl}\"${devnull}"
		#cmd_map[${fl_idx}]="${wgt_cmd} -gencon,\"${grd_dst}\" \"${grd_src}\" \"${map_fl}\"${devnull}"
	    elif [ "${wgt_typ}" = 'esmf' ]; then 
	    	rgn_opt=''
		if [ -n "${hnt_src}" ]; then
		    rgn_opt="${rgn_opt} ${hnt_src}"
		elif [ -f "${hnt_src_fl}" ]; then
		    rgn_opt="${rgn_opt} `cat ${hnt_src_fl}`"
		fi # !hnt_src_fl
		if [ -n "${hnt_dst}" ]; then
		    rgn_opt="${rgn_opt} ${hnt_dst}"
		elif [ -f "${hnt_dst_fl}" ]; then
		    rgn_opt="${rgn_opt} `cat ${hnt_dst_fl}`"
		fi # !hnt_dst_fl
		cmd_map[${fl_idx}]="${wgt_cmd} -s \"${grd_src}\" -d \"${grd_dst}\" -w \"${map_fl}\" --method ${alg_opt} ${wgt_opt} ${rgn_opt}${devnull}"
	    elif [ "${wgt_typ}" = 'nco' ]; then 
		if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		    if [ -n "${msh_opt}" ]; then
			printf "Mesh-File: ${msh_fl}\n"
		    fi # !msh_opt
		fi # !vrb_lvl
		cmd_map[${fl_idx}]="${wgt_cmd} ${wgt_opt} --thr_nbr=${thr_nbr} ${nco_opt} --grd_src=\"${grd_src}\" --grd_dst=\"${grd_dst}\" --map_fl=\"${map_fl}\" ${msh_opt} ${rgr_opt} \"${dmm_fl}\" \"${tmp_out_fl}\"${devnull}"
	    elif [ "${wgt_typ}" = 'mbtempest' ]; then 
		if [ ${prt_alg} = 'zoltan' ]; then
		    cmd_map[${fl_idx}]="${wgt_cmd} --type ${mbt_typ_map} --weights --load \"${grd_src}\" --load \"${grd_dst}\" ${wgt_opt} --file \"${map_fl}\"${devnull}"
		else # !prt_alg
		    cmd_map[${fl_idx}]="${wgt_cmd} --type ${mbt_typ_map} --weights --load \"${grd_src}\" --load \"${grd_dst}\" ${wgt_opt} --file \"${map_fl}\"${devnull}"
		fi # !prt_alg
	    elif [ "${wgt_typ}" = 'tempest' ]; then 
		if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		    printf "Mesh-File: ${msh_fl}\n"
		fi # !vrb_lvl
		cmd_msh[${fl_idx}]="${cmd_msh_tps} ${msh_opt_tps} --a \"${grd_src}\" --b \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
		if [ "${a2o_flg}" = 'Yes' ]; then 
		    cmd_msh[${fl_idx}]="${cmd_msh_tps} ${msh_opt_tps} --b \"${grd_src}\" --a \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
		fi # !a2o_flg
		cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_src}\" --out_mesh \"${grd_dst}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_fl}\" ${wgt_opt}${devnull}"
		if [ "${trn_map}" = 'Yes' ]; then 
		    # NB: Generate mono map for opposite direction regridding (i.e., reverse switches and grids), then transpose
		    cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_dst}\" --out_mesh \"${grd_src}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_trn_fl}\" ${wgt_opt}${devnull}"
		    cmd_trn[${fl_idx}]="GenerateTransposeMap --in \"${map_trn_fl}\" --out \"${map_fl}\"${devnull}"
		fi # !trn_map
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_msh[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_msh[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${msh_fl} ]; then
			printf "${spt_nm}: ERROR Failed to generate intersection mesh-file. Debug this:\n${cmd_msh[${fl_idx}]}\n"
			printf "${spt_nm}: HINT ${msh_exe_tps} requires that grids of unequal area be given as arguments in the order smaller first, larger second. ncremap supplies the grid arguments in the order source first, destination second unless explicitly told otherwise. A source grid that is a superset of the destination would violate the ${msh_exe_tps} rule. The solution is to add the \"--a2o\" switch (documented at http://nco.sf.net/nco.html#a2o) that tells ncremap to swap the grid argument order.\n"
			exit 1
		    fi # !err
		fi # !dbg
	    fi # !wgt_typ
	    
	    # Block 3 Loop 2: Execute and/or echo commands
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_map[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_map[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${map_rsl_fl} ]; then
		    printf "${spt_nm}: ERROR Failed to generate map-file. Debug this:\n${cmd_map[${fl_idx}]}\n"
		    if [ "${wgt_typ}" = 'esmf' ]; then 
			printf "${spt_nm}: HINT When ESMF fails to generate map-files, it often puts additional debugging information in the file named PET0.RegridWeightGen.Log in the invocation directory (${drc_pwd})\n"
		    fi # !esmf
		    exit 1
		fi # !err
		if [ "${map_usr_flg}" = 'Yes' ]; then
		    hst_att="`date`: ${cmd_ln}; ${cmd_map[${fl_idx}]}"
		    cmd_att[${fl_idx}]="ncatted -O ${gaa_sng} --gaa history='${hst_att}' ${gad_sng} \"${map_rsl_fl}\""
		    eval ${cmd_att[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to annotate map-file. Debug this:\n${cmd_att[${fl_idx}]}\n"
		    exit 1
		fi # !err
		fi # !map_usr_flg
	    fi # !dbg
	    if [ "${trn_map}" = 'Yes' ]; then 
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_trn[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_trn[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${map_fl} ]; then
			printf "${spt_nm}: ERROR Failed to transpose map-file. Debug this:\n${cmd_trn[${fl_idx}]}\n"
			exit 1
		    fi # !err
		fi # !dbg
	    fi # !trn_map
	    
	    # Prevent creating new source gridfile and map-file after first iteration
	    if [ "${mlt_map_flg}" = 'No' ] && [ ${fl_idx} -eq 0 ]; then 
		map_mk='Already made map once. Never again.'
	    fi # !mlt_map_flg
	    
	fi # !map_mk
    done # !fl_idx
	
    # 20190920: Nothing to wait() for here since we produce only one map
    
    # Block 4: Special cases
    if [ "${dpt_flg}" = 'Yes' ]; then
	# Block 4a: Add MPAS depth coordinate (prior to permutation)
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "DPT(in)  : ${fl_in[${fl_idx}]}\n"
		printf "DPT(out) : ${dpt_tmp_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_dpt[${fl_idx}]="${cmd_mpi[${fl_idx}]} ${cmd_dpt_mpas} ${cmd_dpt_opt} -i \"${fl_in[${fl_idx}]}\" -o \"${dpt_tmp_fl[${fl_idx}]}\""
	    ${fl_in[${fl_idx}]}=${dpt_tmp_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_dpt[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_dpt[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${dpt_tmp_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to add depth coordinate to MPAS file. Debug this:\n${cmd_dpt[${fl_idx}]}\nHINTS: 1) Verify that ${dpt_exe_mpas} is executable from the command-line, it requires Python and the xarray package to succeed. 2) Verify that ${dpt_fl} or ${fl_in[${fl_idx}]} contains variable \"refBottomDepth\".\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_dpt[${fl_idx}]} ${par_opt}
		    dpt_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx
	
	# Parallel regridding (both Background and MPI) spawns simultaneous processes in batches of ${job_nbr}
	# Once ${job_nbr} jobs are running, wait() for all to finish before issuing another batch
	# Following wait() blocks are identical except for error message and this comment is omitted
	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${dpt_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${dpt_tmp_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to add depth coordinate to MPAS file. Debug this:\n${cmd_dpt[${fl_idx}]}\nHINTS: 1) Verify that ${dpt_exe_mpas} is executable from the command-line, it requires Python and the xarray package to succeed. 2) Verify that ${dpt_fl} or ${fl_in[${fl_idx}]} contains variable \"refBottomDepth\".\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !dpt_flg

    if [ -n "${pdq_opt}" ]; then
	# Block 4b: Generic Permutation/Unpacking (AIRS, HIRDLS, MLS, MOD04, MPAS)
	# Do sub-setting operation (like PDQ) first so cmd_att works on smaller, sub-set files
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "PDQ(in)  : ${fl_in[${fl_idx}]}\n"
		printf "PDQ(out) : ${pdq_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_pdq[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncpdq -O ${nco_opt} ${nco_var_lst} ${pdq_opt} \"${fl_in[${fl_idx}]}\" \"${pdq_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]=${pdq_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_pdq[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_pdq[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${pdq_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to generate pdq-file. Debug this:\n${cmd_pdq[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_pdq[${fl_idx}]} ${par_opt}
		    pdq_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${pdq_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${pdq_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to generate pdq-file. Debug this:\n${cmd_pdq[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !pdq_opt
	
    if [ "${d2f_flg}" = 'Yes' ]; then
	# Block 4c: Double->Float conversion (by-request and possibly default for MPAS)
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "D2F(in)  : ${fl_in[${fl_idx}]}\n"
		printf "D2F(out) : ${d2f_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_d2f[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncpdq -O ${nco_opt} ${nco_var_lst} ${d2f_opt} \"${fl_in[${fl_idx}]}\" \"${d2f_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]=${d2f_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_d2f[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_d2f[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${d2f_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to convert double-precision to single-precision. Debug this:\n${cmd_d2f[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_d2f[${fl_idx}]} ${par_opt}
		    d2f_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${d2f_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${d2f_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to convert double-precision to single-precision. Debug this:\n${cmd_d2f[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !d2f_flg

    if [ "${att_flg}" = 'Yes' ]; then
	# Block 4d: Add missing metadata to MPAS files unless script was invoked by ncclimo (it makes no sense to give naked files to ncclimo and then to annotate them here, so assume ncclimo is working with annotated files)
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "att(in)  : ${fl_in[${fl_idx}]}\n"
		printf "att(out) : ${att_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_att[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncatted -O --type_match -a _FillValue,,o,d,${mss_val} -a _FillValue,,o,f,${mss_val} \"${fl_in[${fl_idx}]}\" \"${att_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]="${att_fl[${fl_idx}]}"
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_att[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_att[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${att_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to annotate MPAS file with _FillValue. Debug this:\n${cmd_att[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_att[${fl_idx}]} ${par_opt}
		    att_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${att_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${att_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to annotate MPAS file with _FillValue. Debug this:\n${cmd_att[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !att_flg

    if [ "${prc_typ}" = 'rrg' ]; then 
	# Block 4e: RRG
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    rrg_dmn_lst=`ncdmnlst ${fl_in[${fl_idx}]} | grep ${rnm_sng}`
	    rrg_var_lst=`ncvarlst ${fl_in[${fl_idx}]} | grep ${rnm_sng}`
	    
	    dmn_sng=''
	    if [ -n "${rrg_dmn_lst}" ]; then
		for dmn in ${rrg_dmn_lst} ; do
		    dmn_sng="${dmn_sng} -d ${dmn},${dmn/${rnm_sng}/}"
		done # !dmn
	    else # !rrg_dmn_lst
		echo "ERROR: Regional regridding suffix string '${rnm_sng}' not found in any dimension names in ${fl_in[${fl_idx}]}"
		echo "HINT: Regional regridding input files must contain dimensions and variables whose names end with the ELM/CAM-SE created (from finclNlonlat namelist input) regional suffix string, e.g., '_128e_to_134e_9s_to_16s'. Valid regional suffix strings for this input file are:"
		eval "ncks -m ${fl_in[${fl_idx}]} | cut -d ':' -f 1 | cut -d '=' -s -f 1 | grep ncol | sed 's/ncol//' | sed -e 's/^ *//' -e 's/ *$//'"
		echo "Use exactly one of these strings as the argument to --rrg_rnm_sng"
		exit 1
	    fi # !rrg_dmn_lst
	    
	    var_sng=''
	    if [ -n "${rrg_var_lst}" ]; then
		for var in ${rrg_var_lst} ; do
		    var_sng="${var_sng} -v ${var},${var/${rnm_sng}/}"
		done # !rrg_var_lst
	    fi # !rrg_var_lst
	    
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "RRG: Remove \"${rnm_sng}\" from dimension and variable names...\n"
	    fi # !vrb_lvl
	    cmd_rnm[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncrename -O ${dmn_sng} ${var_sng} \"${fl_in[${fl_idx}]}\" \"${rnm_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]=${rnm_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_rnm[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_rnm[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to rename regional input file. Debug this:\n${cmd_rnm[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_rnm[${fl_idx}]} ${par_opt}
		    rnm_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${rnm_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to rename regional input file. Debug this:\n${cmd_rnm[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
	
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "RRG: Append regional coordinates and vertices to renamed, annotated regional input data...\n"
	    fi # !vrb_lvl
	    cmd_apn[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncks -A \"${rgn_fl}\" \"${rnm_fl[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_apn[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_apn[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to append regional coordinates and vertices to annotated, regional input data. Debug this:\n${cmd_apn[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_apn[${fl_idx}]} ${par_opt}
		    apn_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${apn_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to append regional coordinates and vertices to annotated, regional input data. Debug this:\n${cmd_apn[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !rrg

    if [ -n "${vrt_out}" ]; then
	# Block 5a: Vertical interpolation
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do

	    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		printf "Vertical : ${vrt_out}\n"
	    fi # !vrb_lvl
	    out_fl=${fl_out[${fl_idx}]}
	    if [ "${flg_hrz}" = 'Yes' ]; then
		out_fl="${drc_tmp}/ncremap_tmp_out_vrt.${fl_idx}.nc"
	    fi # !flg_hrz
	    cmd_rgr[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncks -O -t ${thr_nbr} ${nco_opt} ${nco_var_lst} ${vrt_opt} --vrt_out=\"${vrt_out}\" \"${fl_in[${fl_idx}]}\" \"${out_fl}\""
	    fl_in[${fl_idx}]=${out_fl}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_rgr[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_rgr[${fl_idx}]}
		    if [ "$?" -ne 0 ]; then
			printf "${spt_nm}: ERROR Failed to vertically interpolate. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_rgr[${fl_idx}]} ${par_opt}
		    rgr_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${rgr_pid[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to vertically interpolate. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !vrt_out
    
    if [ "${flg_hrz}" = 'Yes' ]; then
	# Block 5b: Horizontal regridding
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		printf "Map/Wgt  : ${map_fl}\n"
	    fi # !vrb_lvl
	    cmd_rgr[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncks -O -t ${thr_nbr} ${nco_opt} ${nco_var_rgr} ${nco_var_lst_hrz} ${nco_msk_out} ${rgr_opt} --map_fl=\"${map_fl}\" \"${fl_in[${fl_idx}]}\" \"${fl_out[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_rgr[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_rgr[${fl_idx}]}
		    if [ "$?" -ne 0 ]; then
			printf "${spt_nm}: ERROR Failed to horizontally regrid. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_rgr[${fl_idx}]} ${par_opt}
		    rgr_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx
	
	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${rgr_pid[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to horizontally regrid. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !flg_hrz
    
    # Regridding is complete so delete temporary files produced by this batch
    if [ "${cln_flg}" = 'Yes' ]; then
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    /bin/rm -f ${att_fl[${fl_idx}]} ${d2f_fl[${fl_idx}]} ${dpt_tmp_fl[${fl_idx}]} ${pdq_fl[${fl_idx}]} ${rnm_fl[${fl_idx}]} 
	    if [ -n "${vrt_out}" ] && [ "${flg_hrz}" = 'Yes' ]; then
		# Remove vertically regridded intermediate output
		/bin/rm -f "${drc_tmp}/ncremap_tmp_out_vrt.${fl_idx}.nc"
	    fi # !vrt_out
	done # !fl_idx
    fi # !cln_flg
	
    # Block 7: Parallel post-processing
    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	if [ -n "${prc_elm}" ] && [ "${no_cll_msr}" != 'Yes' ]; then
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "${spt_nm}: Implement idiosyncratic CLM/CTSM/ELM characteristics in regridded file...\n"
	    fi # !vrb_lvl
	    # Convert area from [sr] to [km2]
	    cmd_ppp[${fl_idx}]="ncap2 -O -s 'area*=${rds_rth}^2/1.0e6;area@long_name=\"Gridcell area\";area@units=\"km^2\"' \"${fl_out[${fl_idx}]}\" \"${fl_out[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_ppp[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_ppp[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${fl_out[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed post-processing to convert output area from [sr] to [km2]. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_ppp[${fl_idx}]} ${par_opt}
		    ppp_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	fi # !prc_elm

	if [ -n "${prc_cice}" ] && [ "${no_cll_msr}" != 'Yes' ]; then
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "${spt_nm}: Implement idiosyncratic CICE characteristics in regridded file...\n"
	    fi # !vrb_lvl
	    # Convert area from [sr] to [m2], and aice from [frc] to [%]
	    cmd_ppp[${fl_idx}]="ncap2 -O -s 'area*=${rds_rth}^2;area@long_name=\"Gridcell area\";area@units=\"m^2\";${sgs_frc}*=100;${sgs_frc}@units=\"%\"' \"${fl_out[${fl_idx}]}\" \"${fl_out[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_ppp[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_ppp[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${fl_out[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed post-processing to convert output area from [sr] to [m2] and ${sgs_frc} from [frc] to [%]. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_ppp[${fl_idx}]} ${par_opt}
		    ppp_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	fi # !prc_cice

	# Block 8: Other special case post-processing
	if [ "${prc_typ}" = 'hirdls' ] || [ "${prc_typ}" = 'mls' ]; then
	    # NB: Move file to avert problem with --no_tmp_fl causing self-overwrite
	    # fxm: ncwa_fl is not parallel-safe, needs fl_idx suffix
	    cmd_ppp[${fl_idx}]="/bin/mv \"${fl_out[${fl_idx}]}\" \"${ncwa_fl}\";ncwa -O -a lon ${nco_opt} ${nco_var_lst} \"${ncwa_fl}\" \"${fl_out[${fl_idx}]}\""
	    # Block 7 Loop 2: Execute and/or echo commands
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_ppp[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_ppp[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${fl_out[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed post-processing to generate zonal file from lat-lon file. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_ppp[${fl_idx}]} ${par_opt}
		    ppp_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	fi # !znl
    done # !fl_idx

    # Block 9: Wait for post-processing tasks to complete
    if [ -n "${par_opt}" ]; then
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    wait ${ppp_pid[${fl_idx}]}
	    if [ "$?" -ne 0 ]; then
		printf "${spt_nm}: ERROR Failed post-processing step cmd_ppp[${fl_idx}]. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
		exit 1
	    fi # !err
	done # !fl_idx
    fi # !par_opt

done # !bch_idx

if [ "${cln_flg}" = 'Yes' ]; then
    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Clean-up intermediate files...\n"
    fi # !vrb_lvl

    /bin/rm -f ${dmm_fl} ${grd_dst_dfl} ${grd_dst_h5m_tmp} ${grd_dst_prt_tmp} ${grd_src_dfl} ${grd_src_h5m_tmp} ${grd_src_prt_tmp} ${hnt_dst_fl} ${hnt_src_fl} ${map_fl_dfl} ${map_trn_fl} ${msh_fl_dfl} ${ncwa_fl} ${nnt_fl} ${rgn_fl} ${tmp_out_fl} ${znl_fl/znl/znl1} ${znl_fl/znl/znl2}
else # !cln_flg
    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Explicitly instructed not to clean-up intermediate files\n"
    fi # !vrb_lvl
fi # !cln_flg

date_end=$(date +"%s")
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    if [ ${fl_nbr} -eq 0 ]; then
	if [ "${map_mk}" != 'No' ]; then
	    echo "Check statistics of generated map-file:"
	    echo "ncks --chk_map ${map_fl}"
	    echo "AnalyzeMap --map ${map_fl}"
	fi # !map_mk
	printf "Completed generating map/grid-file(s) at `date`.\n"
    else # !fl_nbr
	printf "Completed regridding data file(s) at `date`.\n"
	echo "Quick plots of results from last regridded file:"
	echo "ncvis ${out_fl} &"
    fi # !fl_nbr
    date_dff=$((date_end-date_srt))
    echo "Elapsed time $((date_dff/60))m$((date_dff % 60))s"
fi # !vrb_lvl

exit 0
